[{"title":"Hello World","path":"/2024/11/14/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartHEXO无后端运维和高速渲染页面是静态站点生成器,我使用了 Github Pages 和 Vercel 来部署博客 Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"区块链经济学","path":"/2024/11/07/区块链经济学/","content":"宏观经济学解决三大问题：失业、通货、经济增长问题 凯恩斯主义：强调政府在经济中的作用，通过财政&amp;货币政策调节经济周期，增长需求以促进经济增长和减少失业。 主张政府应在经济低迷时通过增加公共支出、减税、扩大货币供应等方式刺激总需求，从而推动经济复苏。 凯恩斯主义失灵： 长期 vs. 短期：凯恩斯主义主要针对短期经济波动，但在长期内，经济增长往往由其他因素（如技术进步、生产力提升）主导，短期政策的有效性可能减弱。 流动性陷阱：在经济低迷时，利率可能降至接近零，消费者和投资者可能对增加支出缺乏信心，导致“流动性陷阱”现象，使得货币政策失去效力。 政府债务问题：凯恩斯主义强调通过政府支出来拉动经济，但长期的大规模赤字可能导致债务水平过高，进而限制未来政府的财政政策空间。 通货膨胀：使用凯恩斯政策刺激经济可能引发通货膨胀，尤其是在经济接近产能极限时，导致成本上升并降低购买力。 市场自我调节能力：一些学者认为市场在自由条件下具有自我调节能力，过度依赖政府干预可能导致市场失灵或资源的非有效配置。 行为经济学的视角：凯恩斯主义假设人们的决策是理性的，但行为经济学研究表明，人们的决策常常受到心理偏差和非理性因素（投资心理：波动&amp;投机）的影响，这可能导致凯恩斯政策的预期效果被削弱。 滞涨危机：经济停滞和通货膨胀经济增长乏力、高通货膨胀、高失业率 在1970年代，政府干预引发的石油危机、供应链问题及其他因素的影响，导致了严重的滞涨现象。 凯恩斯主义主要关注总需求，通过增加政府支出或降低利率来刺激经济。但滞涨往往是由供给侧问题（如能源危机或生产成本上升）引起的，单纯的需求刺激可能无法解决根本问题。 通常认为增加需求会降低失业率，但在滞涨中，增加需求可能会进一步加剧通货膨胀，而无法有效降低失业。 凯恩斯主义政策的实施时间较长，而滞涨危机往往需要迅速的反应。政策滞后可能导致措施出台时，经济形势已发生变化。 实例： 凯恩斯主义认为，通过政府支出可以刺激需求，但在滞涨情况下，这种政策可能会导致更高的通货膨胀而无助于降低失业率。 在1990年代，尽管日本政府采取了扩张性财政政策和货币政策，但经济长期停滞，消费和投资未能恢复。这表明简单的刺激措施并不足以解决深层的结构性问题。 在2008金融危机后，许多国家采取了大规模的刺激政策。然而，尽管短期内经济有所恢复，但长期的经济增长和就业改善却未如预期。部分经济学家认为，结构性改革的不足使得凯恩斯主义政策效果受到限制。 在一些国家（如日本和欧洲），央行尝试通过负利率来刺激经济。然而，实际效果往往不如预期，银行和消费者对借贷的反应不积极，导致经济增长乏力。 反对凯恩斯主义 ：解决石油危机供给学派经济增长是由供给因素（如生产要素的数量和质量）驱动的，强调降低税收和减少监管，以激励企业投资和增加生产，限制政府的财政支出，尤其是福利政策，以减少对市场的干预。关注长期经济增长，而非短期需求刺激。 供给学派质疑凯恩斯主义的短期刺激措施可能导致长期的通货膨胀和低效的资源配置。 里根经济学（Reganomics）：1980年代美国总统里根实施的经济政策，主要包括减税、减少政府干预和扩大市场自由。 货币学派认为货币供应量是影响经济活动的关键因素，控制货币供应是控制通货膨胀和促进经济增长的主要手段。 与凯恩斯主义的需求管理政策不同，货币学派反对政府对经济进行过度干预，主张中央银行应专注于稳定货币供应，防止通货膨胀。 货币学派主张，经济波动主要由货币供给的变化造成，而凯恩斯主义则过于强调需求方因素。认为凯恩斯主义强调的财政政策效果有限，且可能导致无法控制的通货膨胀。 保罗·沃尔克的货币政策：1980年代，时任美联储主席的保罗·沃尔克通过提高利率来控制高通货膨胀 奥地利经济学派奥地利学派主张强烈反对任何形式的政府干预，反对中央银行的货币政策和政府的财政刺激措施。他们认为政府的干预会扰乱市场价格机制，导致资源错配和长期的经济扭曲，认为市场可以通过自发的秩序实现资源的最优配置。 商品的价值取决于消费者对该商品的需求和欲望，而不是生产者投入的劳动或资本。 奥地利经济学派认为，市场是一种复杂的自发秩序，能够通过价格机制引导资源的最优分配。价格反映了供需之间的动态平衡，能有效协调无数个体的决策，而无需政府的中央规划。 强调人类行为的主观性，认为每个个体的行动是根据主观的目标和偏好做出的，而这些目标和偏好是动态和不可量化的。 不认为人类行为可以完全理性化，也反对将人类行为简化为纯粹的数学模型。个体根据其主观判断和有限的信息做出决策，因此不总是“理性”的。 哈耶克《货币的非国家化》 货币竞争：政府垄断货币发行的结果往往是通货膨胀、货币贬值和经济失衡。相反，如果允许私人机构或市场参与发行货币，货币的价值将更稳定，因为不受政治干预，市场会选择最可靠和最有价值的货币。 去中心化货币发行：他主张由多个机构发行不同的货币，然后让消费者和市场决定哪个货币最能保持其购买力，或者说哪个货币最值得信任。这与现代市场中的产品竞争类似，竞争会迫使货币发行者保持货币的稳定性，否则他们的货币将不被市场接受。 对抗通货膨胀：国家发行的货币受制于政治压力，政府为了短期经济或政治利益，可能会超发货币，导致通货膨胀。而在市场竞争下，发行货币的机构将有强烈的动机保持货币的稳定性，否则市场会抛弃他们的货币。 自由市场货币：哈耶克的理想是货币应该完全由自由市场来管理，而不是由政府控制。市场通过自由竞争和选择，能够自动淘汰劣质货币，选出最优的货币系统。 去中心化与竞争：哈耶克主张多种货币竞争，而比特币作为一种去中心化的数字货币，与政府发行的法定货币形成竞争。在比特币诞生后，还出现了许多其他加密货币，它们共同参与了市场上的货币竞争。这种货币的多样性和竞争性正符合哈耶克的设想。 抗通货膨胀：哈耶克担心政府会通过货币超发导致通货膨胀，而比特币的固定供应量设计正是为了解决这个问题。比特币的设计从根本上防止了货币发行的随意性，符合哈耶克对稳定货币的要求。 去中心化管理：哈耶克的理论认为货币发行应当去中心化，由多个机构竞争。虽然比特币本身没有多个发行者，但它通过区块链技术实现了去中心化的管理，全球数以万计的节点共同维护网络，避免了任何单一实体的控制。 市场驱动的货币选择：在哈耶克的理论中，市场是货币选择的最终决定者，而比特币通过市场力量逐渐获得了认可，尤其是在那些不信任政府或中央银行的地方。市场上的个人和企业可以自由选择使用比特币或其他货币，形成了哈耶克式的货币竞争环境。 《国民经济学原理》提出了边际效用的概念，解释了为什么随着物品数量的增加，个体对它的评价会逐渐递减。这一理论对商品价格的形成机制作出了重要的贡献。强调经济行为是由个体的主观选择驱动的，经济学应当从个体行为的分析出发，而不是从宏观的、整体的经济模型出发。 《人的行动》主张经济学的核心在于理解人类的有目的行为。认为人类的行动都是基于主观的偏好和目的，经济现象的本质是人类行动的结果。而不是依赖数学模型和统计分析。 《美国大萧条》罗斯巴德认为，美联储在1920年代通过人为的低利率和货币扩张，导致了金融市场的泡沫，这直接引发了1929年的股市崩盘和随后的大萧条。 社会主义计划经济存在一个关键的理论缺陷，即信息问题。这是奥地利学派对社会主义和计划经济的一个核心批判。 信息的分散性：在一个自由市场中，价格是供需关系的反映，而供需关系又是个体决策的结果。市场价格包含了关于资源的稀缺性、生产和需求的丰富信息。米塞斯和哈耶克认为，在计划经济中，中央计划者无法有效地获取和处理这些分散在社会中的信息。 无法有效分配资源：计划经济中的中央计划者试图通过集中管理经济来分配资源，但他们无法掌握市场中无数个体的需求和偏好，因为这些信息是分散和动态变化的。没有价格机制，中央计划者无法知道该生产多少、如何分配、消费者真正想要什么，这将导致资源错配和经济低效。 哈耶克的“知识问题”：弗里德里希·哈耶克进一步发展了米塞斯的观点，提出了“知识问题”，即市场中的知识是分散的，中央计划者无法集中所有必要的信息进行有效的经济决策。因此，哈耶克认为自由市场是最有效的经济体系，因为它能够通过价格机制利用分散的信息进行资源分配。 货币危机24.11.06 特朗普当选为美国第 47 任总统牛市是“钱堆出来的”。没有银行支持，大量资金无法流入Crypto市场。而且银行作为资金的主要入口，如果对Crypto保持警惕甚至设立屏障，新资金就会被阻挡在市场之外，难以形成大规模牛市。虽然美国不像大陆那样直接禁止，但银行对Crypto的态度其实是由美联储和政府间接决定的。政府、国会和美联储的监管态度直接影响银行的政策。即使Crypto在法律上并没有被禁止，银行出于谨慎，通常会选择“敬而远之”，这在实际中已经形成了不成文的准入门槛。共和党上台，尤其是特朗普这类相对更支持市场自由的总统执政，可能对金融创新更加宽容，从而放宽银行与Crypto市场的合作空间。 特朗普的经济政策被视为对加密货币市场的潜在利好 减税与加密投资 特朗普的减税政策主张降低企业所得税率并减少资本利得税。这种政策措施减少了投资者的税负，鼓励投资资本涌入高风险、高回报的市场，比如加密货币。对加密资产的投资增多，从需求角度支撑了币价上行。更低的资本利得税吸引了短期投机者的入场，加剧了市场的活跃度和波动性。 去监管与加密创新 特朗普政府多次提倡减少联邦监管，包括金融市场的监管。去监管不仅有利于企业的金融创新，同时也减少了对加密货币和区块链技术创新的限制。更多的创新型项目在宽松环境中得以发展，加密市场的生态丰富性增强，吸引投资者进入。去监管倾向与加密市场的去中心化理念高度一致，激励更多资金涌入这一领域，鼓励了加密市场的交易量和流动性。 美元地位的动摇 特朗普政府的贸易保护主义政策导致了全球市场对美元资产的不安，推动了避险资金进入加密市场。加密货币作为一种去中心化、跨境流通的资产，具备对冲美元贬值的功能。因此，贸易紧张导致的全球市场不确定性反而对比特币等去中心化资产形成了支持性需求。 财政赤字的扩张与加密需求 特朗普政府的财政扩张政策和减税策略加剧了财政赤字，加之疫情带来的大规模支出导致美联储不断扩表。由于凯恩斯主义的政策刺激需要不断的财政支出，加之贸易政策冲突，政府赤字上升，市场对美元资产的信心下滑。去中心化的加密货币提供了对抗政府债务扩张导致的通货膨胀的资产选择。 去中心化货币对抗通胀 凯恩斯主义依赖于政府支出以刺激需求，虽然短期内能够刺激经济增长，但在长期中可能导致高通胀和流动性陷阱。特朗普政策进一步扩展了赤字，加密货币尤其是比特币因此被视作“数字黄金”，成为对抗通胀和美元贬值的工具。比特币和其他稀缺性较强的加密资产在这种环境下成为了保值的首选，增强了其投资吸引力。 &#x20;避险资产的多元化需求 特朗普政府的政策对全球经济和金融市场造成了影响，加剧了市场波动性。尤其是在对美联储的公开压力和利率政策上的干涉，使得投资者对传统金融体系的稳定性有所疑虑。加密货币作为去中心化资产，可以对冲市场的不确定性。对冲基金和高净值投资者逐渐增配加密货币，以多元化投资组合对冲风险，促进了机构资本入场。 奥地利学派经济学的呼应：市场选择与去中心化 特朗普上任期间，更多自由市场和去中心化经济的理念进入主流讨论，增强了加密货币市场的合法性。从奥地利学派角度，去中心化货币如比特币符合哈耶克“货币非国家化”的思想：政府发行的法币由于受到政府开支和货币扩张政策的影响，可能出现通胀；相比之下，加密货币具备去中心化和透明的特点，其数量通常固定，不受单一国家政策干预。 免责声明：根据央行等部门发布“关于进一步防范和处置虚拟货币交易炒作风险的通知”，本文内容仅用于信息分享，本文内容均不构成任何投资建议。不对任何经营与投资行为进行推广与背书，请读者严格遵守所在地区法律法规，不参与任何非法金融行为。","tags":["blockchain"],"categories":["web3"]},{"title":"PicGo+Github搭建图床","path":"/2024/11/06/PicGo-Github搭建图床/","content":"安装PicGohttps://github.com/Molunerfinn/PicGo/releases 安装完在桌面点了好几次没反应，反复卸载，最后看文档才发现是在状态栏处打开。 https://picgo.github.io/PicGo-Doc/zh/guide/#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85 配置GitHub仓库为了使用GitHub作为图床，你需要一个GitHub仓库来存放图片，确保仓库的权限设置为公开，这样别人才能访问你的图片。 生成Personal Access Token (PAT)为了使PicGo能够访问你的GitHub仓库，你需要生成一个Personal Access Token： 登录你的GitHub账户。 访问设置页面，找到“Developer settings”部分。 在“Personal access tokens”中生成一个新的访问令牌。 确保你的访问令牌具有足够的权限来推送到仓库（至少需要repo权限）。 生成后，确保复制并保存你的访问令牌，因为它不会再次显示。 配置PicGo 在PicGo的设置中找到“图床设置”。 选择“GitHub”作为图床服务。 输入你的GitHub仓库名称（格式为username/repo）。 输入你的Personal Access Token。 配置分支名称，默认为main或master。 配置路径前缀，这是你图片存放在GitHub仓库中的目录路径。 保存设置。 PicGo 插件https://github.com/PicGo/Awesome-PicGo vscode-migrator 0.0.2 功能：从 Visual Studio Code 的图片上传插件（如 PicGo 的 VS Code 插件）导入图片。 quick-capture 1.0.0-alpha.2 功能：一个快速截图插件，用于 PicGo，允许用户快速捕捉屏幕并上传图片。 https://github.com/PicGo/picgo-plugin-quick-capture 点击链接看教程 pic-migrator 1.3.2 功能：一个 PicGo 插件，用于在 Markdown 文件中迁移图片链接。 super-prefix 1.2.2 功能：一个 PicGo 插件，用于为上传的文件名添加优雅的前缀。 https://github.com/gclove/picgo-plugin-super-prefix#readme Picgo-plugin-clipboard 功能：允许你将剪贴板中的图片直接上传到配置的图床 可以愉快的使用了","tags":["PicGo","Github"],"categories":["工具"]},{"title":"Git学习","path":"/2024/11/06/Git学习/","content":"Git原理123代码块1代码块2代码块3 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;void dfs()&#123; // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;&#125;int main()&#123; dfs(); return 0;&#125;","tags":["Git"]},{"title":"Markdown格式","path":"/2024/10/11/Markdown/","content":"123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 一级标题二级标题三级标题四级标题五级标题六级标题1###### tags: `This is tag` tags: This is tag列表无序列表：*，+，- 表示无序列表。注意：符号后面一定要有一个空格，起到缩进的作用 123- 列表1 - 列表2- 列表3 列表1 列表2 列表3 有序列表：英文句点后面一定要有一个空格 1231. 列表12. 列表23. 列表3 列表1 列表2 列表3 123&gt; 引用1&gt; 引用2&gt; 引用3 引用1引用2引用3 1 代码块 1 123代码块1代码块2代码块3 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;void dfs()&#123; // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 // 代码块 cout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;&#125;int main()&#123; dfs(); return 0;&#125; 123![图片描述](https://www.example.com/image.jpg) 点击图片可放大1&#123;% image /路径/路径.jpg %&#125; 插入链接12[链接](URL_ADDRESS) markdown教程 强调语法12345678*斜体文本*_斜体文本_**粗体文本**__粗体文本__**_同时斜体和粗体_** 斜体文本斜体文本 粗体文本粗体文本 同时斜体和粗体 任务列表123- [x] 已完成项- [ ] 未完成项 已完成项 未完成项 表格123456| 表头 | 表头 || ---- | ---- || 单元 | 单元 || 单元 | 单元 | 表头 表头 单元 单元 单元 单元 水平分隔线1234567三个或三个以上的符号，必须在独立的一行，前后不能有其他文字--- 短横线***星号___下短线 短横线 星号 下短线","tags":["Markdown"],"categories":["工具"]},{"title":"about","path":"/about/index.html","content":"GinaA lifelong journey of learning and creating"},{"path":"/js/adjust-codeblock-height.js","content":"// 给超长代码块增加滚动条 function adjustCodeBlockHeight() { document.addEventListener(\"DOMContentLoaded\", function () { // 选择所有的.md-text元素 var codeBlocks = document.querySelectorAll('.md-text'); // 遍历每个.md-text元素 codeBlocks.forEach(function (block) { // 检查是否包含.highlight类的子元素，且父元素高度超过500px var highlightBlocks = block.querySelectorAll('.highlight'); highlightBlocks.forEach(function (highlightBlock) { if (highlightBlock.clientHeight > 100) { highlightBlock.style.maxHeight = '300px'; highlightBlock.style.overflow = 'auto'; } }); }); }); } adjustCodeBlockHeight()"},{"path":"/js/l2d.js","content":"addEventListener(\"DOMContentLoaded\", function () { let models = [ { width: 230, height: 350, bottom: \"0px\", right: \"0px\", role: \"https://cdn.jsdelivr.net/gh/imuncle/live2d@master/model/snow_miku/model.json\", background: \"\", opacity: 1, mobile: false, draggable: false, scale: 0.07, }, ]; new Live2dLoader(models); });"},{"path":"/js/chatgpt.js","content":"function ChucklePostAI(config) { // 获取要插入 AI 的文章容器 function getArticleContainer() { let container = null; if (!config.auto_mount && config.el) { container = document.querySelector( config.el || \"#post #article-container\" ); } return container || findLargestContentElement(); } // 计算一个元素的子元素的数量 function countChildElements(element) { let count = 1; Array.from(element.children).forEach((child) => { count += countChildElements(child); }); return count; } // 检查一个元素是否应被排除（如 iframe、footer 等） function shouldExcludeElement(element) { const tagBlacklist = [\"IFRAME\", \"FOOTER\", \"HEADER\", \"BLOCKQUOTE\"]; const classBlacklist = [\"aplayer\", \"comment\"]; return ( tagBlacklist.includes(element.tagName) || Array.from(element.classList).some((className) => classBlacklist.some((cls) => className.includes(cls)) ) ); } // 查找内容最多的 DOM 元素 function findLargestContentElement() { const rootElement = findRootElement(); return findLargestElementInTree(rootElement); } // 查找内容最多的根元素 function findRootElement() { const elementsToCheck = [document.body]; let rootElement = null; let maxCount = 0; while (elementsToCheck.length > 0) { const element = elementsToCheck.shift(); if (shouldExcludeElement(element)) continue; const childCount = countChildElements(element); if (childCount > maxCount) { maxCount = childCount; rootElement = element; } Array.from(element.children).forEach((child) => { elementsToCheck.push(child); }); } return rootElement; } // 查找最大的 DOM 元素 function findLargestElementInTree(rootElement) { const weightMap = { H1: 1.5, H2: 1, H3: 0.5, P: 1 }; let maxWeight = 0; let largestElement = null; function calculateWeight(element) { if (shouldExcludeElement(element)) return; let elementWeight = Array.from(element.children).reduce( (weight, child) => { return weight + (weightMap[child.tagName] || 0); }, 0 ); if (elementWeight > maxWeight) { maxWeight = elementWeight; largestElement = element; } Array.from(element.children).forEach(calculateWeight); } calculateWeight(rootElement); return largestElement; } // 创建并插入 AI 的 UI 元素 function createAIElement() { const aiContainer = document.createElement(\"div\"); aiContainer.className = \"post-ai\"; aiContainer.id = \"post-ai\"; aiContainer.style.cssText = ` margin: 30px 0; `; const aiInterface = { name: \"文章辅助AI\", introduce: \"我是文章辅助AI，点击下方的按钮，让我生成本文简介\", version: \"gpt-3.5-turbo-16k\", buttons: [\"介绍自己\", \"生成摘要\"], ...config.interface, }; aiContainer.innerHTML = ` ${aiInterface.name} 切换简介 ${aiInterface.version} ${aiInterface.name}初始化中... ${aiInterface.buttons .map((btn) => `${btn}`) .join(\"\")} `; bindButtonEvents(aiContainer); const articleContainer = getArticleContainer(); if (articleContainer) { articleContainer.insertBefore(aiContainer, articleContainer.firstChild); } disableButtons(aiContainer); // 禁用按钮 generateSummary(aiContainer); // 初始化时生成文章摘要 } // 绑定按钮事件 function bindButtonEvents(aiContainer) { const generateIntroductionButton = aiContainer.querySelector( \".ai-btn-item:first-child\" ); const generateSummaryButton = aiContainer.querySelector( \".ai-btn-item:last-child\" ); generateIntroductionButton.addEventListener(\"click\", () => { disableButtons(aiContainer); // 禁用按钮 displaySummary( \"我是文章辅助AI，使用的OpenAI的gpt-3.5-turbo, embedding, gpt-4o-mini, gpt-4模型。点击下方的按钮，让我生成本文简介。\", aiContainer ); }); generateSummaryButton.addEventListener(\"click\", () => { disableButtons(aiContainer); // 禁用按钮 generateSummary(aiContainer); // 将 aiContainer 传递给 generateSummary }); } // 禁用所有按钮 function disableButtons(aiContainer) { const buttons = aiContainer.querySelectorAll(\".ai-btn-item\"); buttons.forEach((button) => { button.disabled = true; button.style.pointerEvents = \"none\"; // 禁用点击事件 button.style.opacity = \"0.5\"; // 调整按钮的透明度 }); } // 启用所有按钮 function enableButtons(aiContainer) { const buttons = aiContainer.querySelectorAll(\".ai-btn-item\"); buttons.forEach((button) => { button.disabled = false; button.style.pointerEvents = \"auto\"; // 允许点击事件 button.style.opacity = \"1\"; // 恢复按钮的透明度 }); } // 生成文章摘要 async function generateSummary(aiContainer) { const content = getArticleContent(); const apiKey = \"sk-X0SGzTCLenEtBroX1Nm5nItG1iYP32zAtUKyyT2im62MYWFD\"; // 请替换为你的实际 API KEY const requestBody = { model: \"gpt-3.5-turbo-16k\", messages: [ { role: \"system\", content: \"请为下面的内容生成摘要，以本文讲述了开头，不要出现任何与文章无关的内容。\", }, { role: \"user\", content: content }, ], temperature: 0, }; try { const response = await fetch(\"https://api.chatanywhere.tech\", { method: \"POST\", headers: { \"Content-Type\": \"application/json\", Authorization: `Bearer ${apiKey}`, }, body: JSON.stringify(requestBody), }); if (!response.ok) { throw new Error(\"网络响应不是 OK\"); } const data = await response.json(); displaySummary(data.choices[0].message.content, aiContainer); console.log(\"摘要生成成功:\", data.choices[0].message.content); } catch (error) { console.error(\"请求失败:\", error); } } // 获取文章内容 function getArticleContent() { const articleContainer = getArticleContainer(); return articleContainer ? articleContainer.innerText : \"\"; // 获取文章的文本内容 } // 显示生成的摘要（添加打字机效果） function displaySummary(summary, aiContainer) { const aiSpeechContent = document.querySelector(\".ai-explanation\"); if (aiSpeechContent) { aiSpeechContent.innerText = \"\"; // 清空之前的内容 typeWriterEffect(aiSpeechContent, summary, 15, aiContainer); // 逐字显示摘要 } } // 打字机效果 function typeWriterEffect(element, text, delay, aiContainer) { let index = 0; function type() { if (index < text.length) { element.innerText += text.charAt(index); index++; setTimeout(type, delay); } else { enableButtons(aiContainer); // 打字效果结束后启用按钮 } } type(); } // 初始化函数 function initialize() { createAIElement(); } initialize(); }"},{"title":"GMP模型","path":"/wiki/Go/GMP模型/index.html","content":"GMP模型的基本概念 G（Goroutine）：表示 goroutine，即 Go 语言中的协程。 P（Processor）：P代表逻辑处理器，它是一个抽象的概念，并不是真正的物理CPU。P负责维护一个Goroutine队列，调度Goroutine到M上执行。P的数量通常等于CPU的核心数，可以通过GOMAXPROCS参数来设置。每个 P 负责调度和执行多个 goroutine。包含运行Goroutine的资源和本地队列。 M（Machine）：表示系统线程（即操作系统的内核线程），是执行Goroutine的实体。负责执行 P 中分配的 goroutine。M 通过 P 把 goroutine 绑定到内核线程上执行。当 P 空闲时，可以调度其他 goroutine 执行。 P 的本地队列 ：每个逻辑处理器（P）都有一个本地队列，用于存放等待运行的 Goroutine（G）。这个本地队列的大小是有限的，通常不超过 256 个 Goroutine。这种设计旨在减少锁的使用，提高调度效率，因为访问本地队列不需要加锁。 全局队列： 用于存放那些因为本地队列已满而无法加入的 Goroutine。全局队列是一个共享资源，所有逻辑处理器（P）都可以从中获取 Goroutine 来执行。 GMP模型的工作原理**Goroutine (G)**：比作一个快递包裹。 **线程 (M)**：比作一个分拣员。 **逻辑处理器 (P)**：比作分拣员的工作台。 G与M的绑定机制： （包裹和分拣员的关系）： 想象一下，快递包裹（Goroutine）送到分拣中心后，并不是直接交给某个分拣员（线程），而是先放在分拣员的工作台（逻辑处理器 P）上的包裹堆里。分拣员（M）会从自己工作台上的包裹堆里拿包裹来分拣。 Goroutine并不直接绑定到操作系统线程上，而是通过P来调度。当一个M需要执行工作时，它会从与之关联的P的本地队列中取出一个Goroutine来执行。如果M完成了G的执行或者G被阻塞，M会再次从P的队列中取出另一个G来执行。 P的本地运行队列： （工作台上的包裹堆）： 每个分拣员的工作台（P）上都有一个包裹堆，用来存放等待分拣的包裹。如果分拣员的工作台上没有包裹了，他会去中心的包裹池（全局运行队列）里拿，或者从其他分拣员的工作台上“偷”几个包裹来分拣，这就是工作窃取。 每个P都有一个本地运行队列，用于存储准备好执行的Goroutine。当P的本地队列为空时，它会尝试从全局运行队列或者其他P的本地队列中“偷取”Goroutine来执行，这种策略称为工作窃取（Work Stealing）。 M的休眠与唤醒： （分拣员的休息与工作）： 如果一个分拣员发现自己工作台上没有包裹了，而且中心的包裹池里也没有包裹，他可能会暂时休息，不消耗体力。如果有新的包裹送来，或者有包裹从其他工作台“偷”过来，休息的分拣员会被叫醒来继续工作。 当M在其关联的P的本地队列中找不到可运行的G时，它可能会进入休眠状态。在休眠状态下，M不会消耗CPU资源。当新的Goroutine被创建或者有Goroutine变为可运行状态时，休眠中的M可以被唤醒来处理这些任务。 G的状态转换： （包裹的处理过程）： 快递包裹在分拣过程中会经历几个状态： 可运行（Runnable）：包裹刚送到，等待分拣。 运行中（Running）：分拣员正在分拣这个包裹。 休眠（Waiting）：包裹需要等待某些条件（比如等待特殊处理或者检查）。 死亡（Dead）：包裹已经分拣完毕，可以送出去了。 如果包裹在分拣过程中需要等待（比如等待检查），分拣员会先放下这个包裹，去分拣其他包裹。这就像是 Goroutine 在执行过程中遇到会导致阻塞的操作时，它会从分拣员（M）上解绑并进入休眠状态。 一旦等待的条件满足，分拣员会回来继续分拣这个包裹。这就像是阻塞的操作完成后，Goroutine 会变回可运行状态，并等待被调度器重新分配到分拣员（M）上执行。 Goroutine在其生命周期中会经历几种状态，包括可运行（Runnable）、运行中（Running）、休眠（Waiting）和死亡（Dead）。当G在执行过程中遇到会导致阻塞的操作时，它会从M上解绑并进入休眠状态，等待被唤醒。一旦阻塞的操作完成，G会变回可运行状态，并等待被调度器重新分配到M上执行。 GMP是系统线程运行的代码片段 设计策略复用线程的两个策略： Work Stealing机制： 当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。 Hand Off机制：当本线程因G进行系统调用等阻塞时，线程会释放绑定的P，把P转移给其他空闲的M执行。 利用并行：GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS = 核数/2，则最多利用了一半的CPU核进行并行。 调度器的工作机制：想象一下，你在一个公共场合，大家都在排队上厕所。这里有两种情况： 协作式调度： 每个人都知道自己大概需要多久，如果有人预计自己会占用比较长时间，比如要“大号”，他们会主动告诉后面的人：“我可能需要很久，你们可以先去别的厕所看看。”这样，其他人就有机会先去别的厕所，这就是协作式调度。在 Go 语言中，Goroutine 在执行长时间任务时，会主动让出 CPU，让其他 Goroutine 先执行。 &#x20;Go 语言使用协作式调度机制，意味着 g 在某些特定点（如系统调用、I&#x2F;O 操作）会主动让出 CPU，从而使调度器有机会调度其他 g 执行。这种机制减少了不必要的上下文切换，提高了调度效率。 抢占式调度： &#x20; 但是，有时候有些人进去后，可能因为玩手机或者别的原因，占用厕所时间过长。管理员（调度器）看不下去了，就会敲门说：“你已经待很久了，快点出来，外面还有人等着呢。”这就是抢占式调度。在 Go 语言中，如果一个 Goroutine 占用 CPU 太久，调度器会强制中断它，让其他 Goroutine 有机会执行。 为了防止某个 g 长时间占用 CPU 资源，Go 语言在 1.14 版本中引入了抢占式调度。如果一个 g 占用 CPU 时间过长，调度器会强制中断其执行，并将控制权交还给调度器，确保其他 g 能够得到执行机会。 特殊的 G0 和 M0: G0：每个线程（M）启动时都会创建一个特殊的 Goroutine（G0），它用于调度和系统调用，不指向任何用户代码。G0 在调度器需要执行系统调用或者进行调度操作时使用。 M0：程序启动后的第一个主线程（M0）负责执行初始化操作和启动第一个 Goroutine。此后，M0 的行为与其他线程（M）相同。 1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Hello world&quot;)&#125; 接下来我们来针对上面的代码对调度器里面的结构做一个分析。 也会经历如上图所示的过程： 创建初始线程和Goroutine： Go 程序启动时，runtime 包会创建一个初始线程 m0 和一个特殊的 Goroutine g0。g0 是每个线程的调度器 Goroutine，用于执行系统调用和调度操作。 调度器初始化： 初始化线程 m0、栈、垃圾回收器，以及创建由 GOMAXPROCS（可以设置的，决定了同时运行的线程数）个 P（Processor，逻辑处理器）构成的 P 列表。每个 P 都与一个 M（Machine，物理线程）关联。 main函数的调用： 示例代码中的 main 函数是用户定义的 main.main，而在 runtime 包中也有一个 main 函数，即 runtime.main。编译后的代码会将 runtime.main 调用 main.main。 程序启动时，会为 runtime.main 创建一个 Goroutine，我们可以称之为 main goroutine。这个 Goroutine 会被加入到 P 的本地队列中。 启动 m0： m0 启动后，会绑定到一个 P 上，并从 P 的本地队列中获取 G（Goroutine），即获取到 main goroutine。 设置运行环境： 每个 G 都有自己的栈。M 会根据 G 中的栈信息和调度信息设置运行环境。 运行 G： M 开始运行 G。在这个例子中，main goroutine 会执行 main.main 函数，打印 “Hello world”。 G 退出和循环： 当 G 执行完毕后，M 会尝试获取下一个可运行的 G。这个过程会一直重复，直到 main.main 退出。 一旦 main.main 退出，runtime.main 会执行任何延迟函数（Defer）和 Panic 处理，或者调用 runtime.exit 来退出程序。 GMP模型的工作流程&#x2F;调度策略 **Goroutine (G)**：比作一个快递包裹。 **线程 (M)**：比作一个分拣员。 **逻辑处理器 (P)**：比作分拣员的工作台。 新建 Goroutine（新快递包裹到达）： 当新的快递包裹（Goroutine）送到分拣中心时，调度器会优先将这些包裹放到当前分拣员（P）的工作台上（本地队列）。如果工作台上的包裹已经很多了，超出了一定数量，那么一半的包裹会被移动到中心的包裹池（全局队列）中，以便其他分拣员可以处理。 通过go func()创建一个协程，调度器会将其视为一个新的任务，并优先放入当前逻辑处理器（P）的本地队列（Local RunQueue）中。如果本地队列已满，会将一半的（G）移动到全局队列中。 优先本地队列调度（分拣员优先处理自己工作台上的包裹）： 分拣员（M）在工作时，会优先处理自己工作台上的快递包裹（从绑定的 P 的本地队列中获取 G 进行执行）。这种方式不需要分拣员之间互相沟通，提高了分拣效率，因为每个分拣员都专注于自己的工作台。 线程（M）在需要执行 Goroutine 时，会优先从其绑定的逻辑处理器（P）的本地队列中获取 Goroutine 进行执行。这种方式避免了锁的使用，提高了调度效率。 全局队列调度（分拣员从中心包裹池获取包裹）： 如果分拣员发现自己工作台上的包裹都处理完了，他们会去中心的包裹池（全局队列）看看有没有新的包裹可以处理。这个过程需要分拣员之间协调（加锁），虽然比直接处理自己工作台上的包裹慢一些，但可以确保整个分拣中心的包裹都能得到处理，保持负载均衡。 如果逻辑处理器（P）的本地队列为空，线程（M）会尝试从全局队列（Global RunQueue）中获取 Goroutine。访问全局队列需要加锁，这是一个相对较慢的过程，但它确保了系统的负载均衡。 工作窃取（分拣员从其他工作台“偷”包裹）： 如果分拣员发现自己工作台上和中心包裹池里都没有包裹了，而其他分拣员的工作台上还有包裹，他们可以走过去，从其他分拣员的工作台上“偷”一些包裹来处理。这样可以避免一些分拣员太忙而其他分拣员太闲的情况，确保所有分拣员都能保持忙碌。 如果线程（M）从逻辑处理器（P）的本地队列和全局队列都无法获取到 Goroutine，它会尝试从其他逻辑处理器的本地队列中“偷取”一部分 Goroutine 来执行，这种策略称为工作窃取（Work Stealing）。 Goroutine 的阻塞与唤醒（快递包裹因特殊处理而暂时搁置）： 当快递包裹在分拣过程中需要等待某些特殊处理（比如等待检查或者需要特别的分拣规则），分拣员会暂时将这个包裹放到一边，去处理其他包裹。这就像是 Goroutine 在执行过程中遇到会导致阻塞的操作时，它会从分拣员（M）上解绑并进入休眠状态。 一旦需要等待的特殊处理完成，这个包裹会被重新放回某个分拣员的工作台上（P 的本地队列），等待下一个可用的分拣员（M）来继续处理。 当 Goroutine 在执行过程中遇到会导致阻塞的操作（如 I&#x2F;O 操作或系统调用），它会从线程（M）上解绑并进入休眠状态（Waiting State）。一旦阻塞的操作完成，Goroutine 会被唤醒，并变回可运行状态（Runnable State），等待被调度器重新分配到线程（M）上执行。 GMP模型的优势 高效的资源利用：通过在用户态进行调度，避免了频繁的上下文切换带来的开销，充分利用CPU资源。 轻量级并发：Goroutine比线程更加轻量级，可以启动大量的Goroutine而不会消耗大量内存。 自动调度：Go运行时自动管理Goroutine的调度，无需程序员手动干预，简化了并发编程的复杂度。 参考链接操作系统篇一:进程与线程、并发并行与串行、同步与异步、阻塞与非阻塞当你被问到这些问题:你觉得的并发、并行、串行有什么区别 - 掘金 第三篇、Golang编程设计与通用之路 - 3、对于操作系统而言进程、线程以及Goroutine协程的区别 - 《Golang 修养之路》 - 书栈网 · BookStack 翻译来自 Goroutines 《Go语言轻松进阶:从入门、实战到内核揭秘》 GMP模型"},{"title":"goroutine(协程)","path":"/wiki/Go/goroutine(协程)、GMP模型/index.html","content":"串行、并行、并发 让我们想象一个人慢跑。当他晨跑时，假设他的鞋带解开了。现在这个人停止了跑步，系好鞋带，然后又开始跑步。这是并发的一个典型示例。这个人能够处理跑步和系鞋带，也就是说，这个人能够同时处理很多事情。 并行指的是多个事情在 同一个时间点&#x20;&#x4E0A;同时发生了。 并发指的是多个事情在 同一时间段&#x20;&#x5185;同时发生了。 Go 是一种并发语言，而不是一种并行语言。 进程（Process）（并行运算，分布式） 定义：进程就是程序在操作系统中的一次执行过程，是系统进行资源调度和分配的基本单位。每个进程都有自己的一套独立的地址空间，这意味着进程间的内存是不共享的，每个进程都像是操作系统中的一个独立实体。比如，你打开一个浏览器，这就是一个进程；再打开一个文档编辑器，这是另一个进程。每个进程都有自己的空间，不会互相干扰。 资源：进程拥有独立的资源，包括内存、文件描述符、环境变量等。 调度：进程由操作系统进行调度，操作系统决定哪个进程在何时运行。 单道批处理系统内存中始终只保持一道作业，cpu 只能将内存中作业执行完毕，才能执行下一道作业，进程之间串行执行，A、B、C 三个进程按顺序执行 分时系统引申出了时间片的概念，进程按照调度算法分时间片在 CPU 上执行，A、B、C 三个进程按照时间片并发执行 线程（Thread）（并发执行）在进程的基础上再细分出线程，线程比进程更轻量，线程之间的通信也更为便捷，任务的最小载体变成了线程。 定义：线程是进程中的一个实体，是被系统独立调度和分派的基本单位，是程序执行的一个最小单位。线程自身不拥有系统资源，只拥有一点在运行中必不可少的资源（如执行栈），但它可以与同属一个进程的其他线程共享进程所拥有的全部资源。 并行执行：在多核处理器上，同一个进程中的多个线程可以并行执行，即同时在不同的处理器上运行。 共享资源：同一进程内的线程共享进程的资源，包括内存、文件句柄等，但每个线程有自己的程序计数器、寄存器和堆栈。 &#x20; CPU 内核负责调度，为系统提供并发处理能力。 &#x20; 协程是在用户空间实现的， CPU 并不知道有 “用户态线程” 的存在，CPU 只知道它运行的是一个 “内核态线程”。 这里我们可以把 内核线程依然叫“线程(thread)”，用户线程叫“协程(co-routine)”。 &#x20; &#x20;线程越多，进程利用(或者)抢占的cpu资源就越高。 &#x20; 进程和线程的创建、切换和销毁都会消耗大量 CPU 资源。 &#x20; 每个线程约需 4MB 内存，大量线程会导致内存消耗过高。应用层无法直接控制内核调度，只能通过减少线程创建和切换来优化性能。这促生了协程的概念：用户级别的轻量线程。 协程（Coroutine）（并发执行） 定义：协程是一种程序组件，它允许挂起和恢复执行。goroutine是由Go运行时管理的轻量级线程，与coroutine只能运行在一个线程上不同，goroutine可以运行在一个或多个线程上。 轻量级：goroutine比线程更加轻量级，因为它们的栈是动态的，并且可以在运行时调整大小，它们的堆栈大小只有几 kb，并且堆栈可以根据应用程序的需要进行扩展和收缩，而对于线程，则必须指定堆栈大小并固定堆栈大小。 并发执行：在Go语言中，goroutine可以在单个操作系统线程中并发执行，Go运行时会负责调度这些goroutine，让它们在线程之间高效地共享和切换。 共享资源：多个goroutine共享同一个线程的资源，但拥有自己的栈和寄存器。它们通过channel进行通信，这是一种同步机制，可以用来传递数据和同步goroutine。 Go 协程和线程的区别Go 语言引入了 goroutine（协程），它是一个比线程更轻量级的并发执行单元。 更小的内存占用： 每个线程的栈内存通常是固定的（通常为 1MB 或更多）。 goroutine 的栈内存默认仅占用约 2KB，可以根据需要自动增长和收缩。 调度机制不同： 线程由操作系统调度，切换线程的开销较大，因为需要在用户态和内核态之间切换。 goroutine 是由 Go 运行时（runtime）调度的，属于用户态调度，切换开销更小。 什么是runtime?Go语言程序执行的环境，它提供了一些底层服务，并发支持(goroutine)和协程调度，垃圾回收，内存管理，反射,网络和文件I/O。 数量可达数十万： 创建一个线程的系统开销很大，不适合大规模并发。 goroutine 非常轻量，因此可以轻松创建成千上万个 goroutine，并发处理大量任务。 goroutine 的基本使用goroutine 是 Go 中的轻量级线程，启动一个 goroutine 只需要使用 go 关键字，非常高效。每个 goroutine 都是独立的，多个 goroutine 可以并发执行。 1234567891011121314package mainimport ( &quot;fmt&quot;)func hello() &#123; fmt.Println(&quot;Hello world goroutine&quot;)&#125; func main() &#123; go hello() fmt.Println(&quot;main function&quot;)&#125; 12345678910111213141516171819202122package mainimport ( &quot;fmt&quot; &quot;time&quot;)func printNumbers() &#123; for i := 1; i &lt;= 5; i++ &#123; fmt.Println(i) time.Sleep(100 * time.Millisecond) // 延迟 100 毫秒 &#125;&#125;func main() &#123; go printNumbers() // 启动一个新的 goroutine，并发执行 printNumbers 函数 fmt.Println(&quot;这是在主 goroutine 中&quot;) time.Sleep(600 * time.Millisecond) // 等待 printNumbers 执行完 fmt.Println(&quot;主 goroutine 结束&quot;)&#125; 1234567这是在主 goroutine 中12345主 goroutine 结束 参考链接操作系统篇一:进程与线程、并发并行与串行、同步与异步、阻塞与非阻塞当你被问到这些问题:你觉得的并发、并行、串行有什么区别 - 掘金 第三篇、Golang编程设计与通用之路 - 3、对于操作系统而言进程、线程以及Goroutine协程的区别 - 《Golang 修养之路》 - 书栈网 · BookStack 翻译来自 Goroutines 《Go语言轻松进阶:从入门、实战到内核揭秘》 GMP模型"},{"title":"函数、init函数、包、闭包、错误处理","path":"/wiki/Go/函数、init函数、包、闭包、错误处理/index.html","content":"golang函数特点：&#x20; • 无需声明原型。&#x20; • 支持不定 变参。&#x20; • 支持多返回值。&#x20; • 支持命名返回参数。&#x20; • 支持匿名函数和闭包。&#x20; • 函数也是一种类型，一个函数可以赋值给变量。 &#x20; • 不支持 嵌套 (nested) 一个包不能有两个名字一样的函数。&#x20; • 不支持 重载 (overload)&#x20; • 不支持 默认参数 (default parameter)。 1234//函数声明告诉了编译器函数的名称，参数，和返回类型func function_name( [parameter list] ) [return_types] &#123; 函数体&#125; func：函数由 func 开始声明 function_name：函数名称，参数列表和返回值类型构成了函数签名。 parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数是可选的，也就是说函数也可以不包含参数。可以定义多个参数，多个参数之间用逗号分隔。 return_types：返回类型，函数返回一列值。 return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。可以有返回值，也可以没有 函数体：函数定义的代码集合。 1234567//函数可以返回多个值func divide(a, b float64) (float64, error) &#123; if b == 0 &#123; return 0, fmt.Errorf(&quot;division by zero&quot;) &#125; return a / b, nil&#125; 123456//具名返回值允许我们不显式地使用 return 语句来返回结果，Go 会自动返回最后的变量值func swap(a, b int) (x, y int) &#123; x, y = b, a return&#125;//x 和 y 是具名返回值，不需要显式地写 return x, y，仅 return 即可 函数值传递在Go语言中，函数可以像任何其他变量一样被赋值给变量或作为参数传递给其他函数。 值类型：在Go语言中，基本数据类型（如int、float、bool、string）和复合数据类型（如数组、结构体）都是值类型。 存储位置：值类型通常存储在栈（stack）上。 参数传递：当值类型作为函数参数传递时，实际上是传递了该值的拷贝。 修改影响：在函数内部对参数值的修改不会影响到函数外部的原始值。 123456789101112131415//基本数据类型（int）package mainimport &quot;fmt&quot;func main() &#123; num := 10 change(num)//调用 change 函数，并将 num 作为参数传递 fmt.Println(num) // 输出 10&#125;func change(num int) &#123; num = 998 //参数 num 被修改为 998，但这不会影响 main 函数中的 num，因为整数是值类型，传递的是值的拷贝&#125; 1234567891011121314//数组package mainimport &quot;fmt&quot;func main() &#123; arr := [3]int&#123;1, 3, 5&#125; change(arr)//调用 change 函数，并将 arr 作为参数传递。 fmt.Println(arr) // 输出 [1 3 5]&#125;func change(arr [3]int) &#123; arr[1] = 8 //参数 arr 的第二个元素被修改为 8，但这不会影响 main 函数中的 arr，因为数组是值类型，传递的是数组的拷贝&#125; 12345678910111213141516171819//结构体package mainimport &quot;fmt&quot;type Person struct &#123; name string age int&#125;func main() &#123; p := Person&#123;&quot;lnj&quot;, 33&#125; change(p)//调用 change 函数，并将 p 作为参数传递 fmt.Println(p.name) // 输出 lnj&#125;func change(p Person) &#123; p.name = &quot;zs&quot; //参数 p 的 name 字段被修改为 &quot;zs&quot;，但这不会影响 main 函数中的 p，因为结构体是值类型，传递的是结构体的拷贝&#125; 函数引用传递 引用类型：在Go语言中，指针、切片（slice）、映射（map）和通道（channel）是引用类型。 存储位置：引用类型通常存储在堆（heap）上，并通过指针来访问。 参数传递：当引用类型作为函数参数传递时，实际上是传递了指向该值的指针，即引用传递。 修改影响：在函数内部对参数的修改会影响到函数外部的原始值。 123456789101112131415//指针package mainimport &quot;fmt&quot;func main() &#123; num := 10 change(&amp;num)//调用 change 函数，并将 num 的地址作为参数传递 fmt.Println(num) // 输出 998&#125;func change(num *int) &#123; *num = 998 //参数 num 是一个指向整数的指针，通过解引用 *num 将值修改为 998。 //因为传递的是地址，所以 main 函数中的 num 也被修改。&#125; 1234567891011121314//切片package mainimport &quot;fmt&quot;func main() &#123; arr := []int&#123;1, 3, 5&#125; change(arr)//调用 change 函数，并将 arr 作为参数传递 fmt.Println(arr) // 输出 [1 8 5]&#125;func change(arr []int) &#123; arr[1] = 8 //参数 arr 指向同一个切片，所以修改 arr 的第二个元素为 8 会影响到 main 函数中的 arr&#125; 1234567891011121314//映射package mainimport &quot;fmt&quot;func main() &#123; mp := map[string]string&#123;&quot;name&quot;: &quot;lnj&quot;, &quot;age&quot;: &quot;33&quot;&#125; change(mp)//调用 change 函数，并将 mp 作为参数传递 fmt.Println(mp[&quot;name&quot;]) // 输出 zs&#125;func change(mp map[string]string) &#123; mp[&quot;name&quot;] = &quot;zs&quot; //参数 mp 指向同一个映射，所以修改 mp 中的 &quot;name&quot; 键对应的值为 &quot;zs&quot; 会影响到 main 函数中的 mp&#125; init函数在Go语言里，init函数就像是一个特殊的“准备”按钮。它是一个不需要你手动去按的按钮，程序在开始运行的时候会自动帮你按这个按钮。这个按钮的作用就是做一些准备工作，比如设置好环境，让你的程序能够顺利地开始工作。 定义：init函数是一个特殊的函数，用于初始化操作。它没有参数，没有返回值，且不能被显式调用。 自动调用：程序在启动时会自动调用init函数，且在main函数执行之前。 123456func init()&#123; fmt.Println(&quot;init先执行&quot;)&#125;func main()&#123; fmt.Println(&quot;main后执行&quot;)&#125; 执行顺序：在同一个包中，init函数的执行顺序是按照它们在代码中出现的顺序。如果一个包中有多个文件，那么init函数的执行顺序是按照文件名的字典顺序。 全局变量初始化：全局变量的初始化是在init函数执行之前进行的。如果全局变量依赖于函数调用的结果，那么这个函数会在相关的init函数执行之前被调用。 无参数和返回值：init函数没有参数，也不返回任何值。 可重复定义：一个包中可以定义多个init函数，它们会按照它们在代码中出现的顺序执行。 用途：init函数通常用于那些不能通过简单声明或全局变量赋值来完成的初始化工作，比如配置文件的加载、环境变量的设置、日志系统的初始化等。 12345678package mypackageimport &quot;fmt&quot;func init() &#123; fmt.Println(&quot;mypackage 初始化&quot;)&#125; 作用与调用时机： init()函数用于在包被导入时执行一次性的初始化操作。每个包可以包含多个init()函数，它们会在包被导入时自动执行。 当包被导入时，init()函数会按照导入的顺序自动执行。同一个包中的多个init()函数按照编写的顺序执行。 使用方式： init()函数的定义和普通函数类似，只是函数名为init。它没有参数和返回值，不需要手动调用，而是在包被导入时自动执行。 应用场景： 常用于初始化包的配置信息，例如读取配置文件，进行初始化设置。 123456789101112131415161718192021222324package configimport ( &quot;log&quot; &quot;os&quot;)var Config = struct &#123; Database string Port int&#125;&#123;&#125;func init() &#123; // 假设配置文件名为 config.ini configFile, err := os.Open(&quot;config.ini&quot;) if err != nil &#123; log.Fatal(&quot;Failed to open config file: &quot;, err) &#125; defer configFile.Close() // 读取配置文件并设置到Config变量中 // 这里省略了具体的解析代码 // ...&#125; 用于数据库初始化，比如建立数据库连接，进行必要的数据表创建等操作。 123456789101112131415161718192021222324package dbimport ( &quot;database/sql&quot; _ &quot;github.com/go-sql-driver/mysql&quot; &quot;log&quot;)var DB *sql.DBfunc init() &#123; var err error // 连接数据库 DB, err = sql.Open(&quot;mysql&quot;, &quot;user:password@/dbname&quot;) if err != nil &#123; log.Fatal(&quot;Error connecting to the database: &quot;, err) &#125; // 测试数据库连接 err = DB.Ping() if err != nil &#123; log.Fatal(&quot;Error pinging the database: &quot;, err) &#125;&#125; 注册功能插件，当包中存在多个功能插件需要在包被导入时注册到主程序中。 12345678910111213package pluginvar Plugins = []func()&#123;&#125;func init() &#123; // 注册插件 Plugins = append(Plugins, func() &#123; // 插件1的代码 &#125;) Plugins = append(Plugins, func() &#123; // 插件2的代码 &#125;)&#125; 与main函数的异同： 相同点：两个函数在定义时不能有任何的参数和返回值，且Go程序自动调用（一般函数都要先声明，再调用。而 init 函数和 main 函数只声明就行，Go 程序会自己进入）。 不同点：init()可以应用于任意包中，且可以重复定义多个；main函数只能用于main包中，且只能定义一个。 包在Go语言开发中，我们经常需要在不同的文件之间共享代码，比如在一个文件中定义函数，在另一个文件中使用这个函数。这就是包（package）的作用之一。此外，如果两个程序员都想在同一个项目中定义同名的函数，使用包可以避免命名冲突。 在Go语言中，包（package）是代码组织的基本单位。一个包可以包含多个.go源文件，它们共享相同的包名。包的使用包括定义包、编译包以及在包中定义函数、变量和类型。 123456// math.gopackage mathfunc Add(a, b int) int &#123; return a + b&#125; 123456// utils.gopackage utilsfunc Add(a, b int) int &#123; return a + b + 100 // 这个Add函数有一些额外的操作&#125; 123456789101112package mainimport ( &quot;fmt&quot; &quot;project/math&quot; &quot;project/utils&quot;)func main() &#123; fmt.Println(math.Add(1, 2)) // 输出 3 fmt.Println(utils.Add(1, 2)) // 输出 103&#125; 在main.go文件中，我们导入了math和utils包，并使用它们各自的Add函数。由于每个函数都通过其包名进行了限定，因此即使函数名称相同，也不会发生冲突。我们可以通过math.Add来调用math包中的Add函数，通过utils.Add来调用utils包中的Add函数。 作用 区分标识符：包的使用可以区分相同名字的函数、变量等标识符，即使在不同的包中。 项目管理：当程序文件很多时，包可以帮助我们更好地管理和组织项目。 控制访问：包可以控制函数、变量等的访问权限，即它们的作用域。 1234package 包名//包名应该小写，因为Go的包名是全局唯一的，并且通常以小写字母开头。//包的目录结构应该反映包的名称。//包应该尽量保持小而专注，每个包只做一件事情。 1import &quot;包的路径&quot; &#x20;main包main包是Go程序的入口点。每个可执行的Go程序都必须包含一个main包，其中包含main函数。 1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Println(&quot;Hello, World!&quot;)&#125; 匿名函数匿名函数是Go语言中没有函数名的函数。它们通常用于需要函数的地方，但又不想为函数命名的场景。匿名函数可以被赋值给一个变量，或者直接作为参数传递给另一个函数。 匿名函数使用方法直接调用就像是你直接用工具做了一件事。 123456789101112package mainimport &quot;fmt&quot;func main() &#123; // 定义即调用，用于输出一条日志信息 func() &#123; fmt.Println(&quot;程序启动成功&quot;) &#125;() // 程序的其他逻辑...&#125; 定义了一个匿名函数来输出一条日志信息，然后立即调用它。这个函数只在程序启动时使用一次，之后就不再需要了。 123456789101112131415161718192021222324package mainimport &quot;fmt&quot;func main() &#123; // 尝试执行一个操作 if err := doSomething(); err != nil &#123; // 定义即调用，用于处理错误 func() &#123; fmt.Println(&quot;发生错误:&quot;, err) // 执行一些清理工作 &#125;() // 返回或者结束程序 return &#125; // 程序的其他逻辑...&#125;func doSomething() error &#123; // 模拟一个可能失败的操作 return nil // 或者返回一个错误&#125; 如果doSomething函数返回一个错误，我们定义并立即调用一个匿名函数来处理这个错误，比如输出错误信息并执行清理工作。 保存到变量就像是你把这个工具保存起来，以后还可以再用。 123456789101112131415package mainimport &quot;fmt&quot;func main() &#123; myTool := createTool() myTool() // 使用保存的工具 myTool() // 再次使用保存的工具&#125;func createTool() func() &#123; return func() &#123; fmt.Println(&quot;这个函数被保存到变量中，可以多次使用&quot;) &#125;&#125; 作为参数和返回值就像是你把这个工具带到了别的地方（作为参数），或者你得到了一个新的工具（作为返回值）。 作为参数: 1234567891011121314151617package mainimport &quot;fmt&quot;func main() &#123; processTask(handleTask)&#125;func processTask(task func()) &#123; fmt.Println(&quot;处理任务前...&quot;) task() // 调用传递来的工具 fmt.Println(&quot;处理任务后...&quot;)&#125;func handleTask() &#123; fmt.Println(&quot;这是传递给processTask的任务&quot;)&#125; handleTask 是一个匿名函数，我们把它作为参数传递给了 processTask 函数 作为返回值: 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; myTool := getTool() myTool() // 使用新得到的工具&#125;func getTool() func() &#123; return func() &#123; fmt.Println(&quot;这是从函数返回的新工具&quot;) &#125;&#125; getTool 函数返回一个匿名函数，我们得到了这个新工具，并在 main 函数中使用它 一次性匿名函数在定义匿名函数的时候就调用，此时匿名函数就只能使用一次 1234567fun main()&#123; //定义即调用 func(n1 int,n2 int)int&#123; return n1 + n2 &#125;(10,20) //此时在定义的时候同时调用 &#125; 🚀 编译结果如下： 130 赋值给变量调用 可重复使用的匿名函数这种方式的匿名函数可以多次调用，之前我们说过函数也是一种数据类型，那么将这个函数直接定义一个变量然后赋值。 这种方式就像是你有一本食谱，你可以按照食谱上的指示多次制作同一种蛋糕。每次你想要做蛋糕时，都会按照食谱上的步骤来操作。 12345myFunc := func() &#123; fmt.Println(&quot;这个函数可以多次使用&quot;)&#125;myFunc() // 第一次调用myFunc() // 第二次调用 123456789101112131415package mainimport &quot;fmt&quot;func main() &#123; // 定义匿名函数并赋值给变量a a := func(n1 int, n2 int) int &#123; return n1 - n2 &#125; // 通过变量a调用匿名函数 res := a(30, 20) fmt.Println(&quot;res=&quot;, res) // 正确打印res的值 res2 := a(30, 40) fmt.Println(&quot;res2=&quot;, res2) // 修正变量名，并正确打印res2的值&#125; 🚀 编译结果如下： 12res= 10res3= -10 全局匿名函数这些是没有名字的函数，但是它们可以在程序的任何地方被调用，因为它们被定义在全局范围内。就像你家里的公共工具，比如剪刀，你可以在任何需要的时候找到并使用它们。 1234567891011package mainimport &quot;fmt&quot;var globalFunc = func() &#123; fmt.Println(&quot;这个函数是全局的，在整个程序中都可以访问&quot;)&#125;func main() &#123; globalFunc() // 调用全局匿名函数&#125; 匿名函数就像是你生活中的“即用即抛”工具，它们不需要长期维护，也不需要占用你太多的资源。你可以在需要的时候快速使用它们，然后继续你的工作和生活。它们特别适合那些不需要重复使用或者只在特定情况下需要的功能。通过使用匿名函数，你的代码可以变得更加灵活和高效，就像你的生活因为有了这些即用即抛的工具而变得更加方便一样。 闭包在一个厨房里做蛋糕，你有一个秘密配方（闭包），这个配方不仅告诉你需要哪些步骤（函数体），还告诉你需要用到哪些特别的调料（外部变量）。即使你离开了厨房，这个配方还是能记住你需要哪些调料，并且每次你按照这个配方做蛋糕时，都能用到这些调料。 闭包就像是一个“记忆盒子”，它是一个函数，但是这个函数能够记住它在哪里被创建，以及那时候周围的情况。即使创建它的那个环境（比如一个函数）已经结束了，闭包仍然能够记住那些信息。 闭包的特点 记住变量：闭包可以记住它被创建时周围的变量，即使那些变量在外部函数中已经不可见。 可以修改记忆：闭包不仅能记住变量，还能改变它们，就像那些变量一直存在一样。 延迟执行：闭包可以在需要的时候才执行，即使创建它的外部函数已经执行完毕。 闭包怎么工作的？闭包通过在函数内部定义另一个函数来实现。内部函数能够访问外部函数的变量，即使外部函数已经执行完毕。 闭包是一个特殊的匿名函数, 它是匿名函数和相关引用环境组成的一个整体， 也就是说只要匿名函数中用到了外界的变量, 那么这个匿名函数就是一个闭包。 1234567891011121314151617181920212223//Go 支持匿名函数，这意味着可以在函数内部定义并调用函数，匿名函数也可以作为变量传递。func main() &#123; // 定义一个匿名函数并赋值给变量add add := func(a, b int) int &#123; return a + b &#125; fmt.Println(add(3, 4)) // 输出 7 // 定义一个返回闭包的函数，是一个秘密配方，每次调用都会记住上次做到哪一步了 counter := func() func() int &#123; count := 0 // 这是一个在counter函数内部定义的变量。闭包中的外部状态，就像你做蛋糕时的步骤记录 return func() int &#123; // 返回一个匿名函数，这个函数是一个闭包 count++ // 闭包可以访问并修改外部的count变量，闭包函数体，它修改了外部状态，就像你按照配方一步步做 return count &#125; &#125; c := counter() // 调用counter函数，得到一个闭包 // 按照配方做蛋糕，每次都会记住上次做到哪一步 fmt.Println(c()) // 输出 1 fmt.Println(c()) // 输出 2&#125;//闭包是可以引用其外层作用域的变量的函数。 &#x20; 闭包中使用的变量和外界的变量是同一个变量, 所以可以闭包中可以修改外界变量 1234567891011121314package mainimport &quot;fmt&quot;func main() &#123; num := 10 // 这是main函数中的变量 a := func() &#123; // 定义一个匿名函数并赋值给变量a num = 6 // 在闭包中修改了main函数中的num fmt.Println(num) // 输出修改后的值：6 &#125; fmt.Println(&quot;执行闭包前&quot;, num) // 输出：10 a() // 调用闭包 fmt.Println(&quot;执行闭包后&quot;, num) // 输出闭包修改后的值：6&#125; 闭包a“记住了”变量num，并且能够修改它。当你调用a()时，闭包不仅打印出了修改后的num值，而且这个修改也影响到了main函数中的num变量。 只要闭包还在使用外界的变量, 那么外界的变量就会一直存在 12345678910111213141516171819package mainimport &quot;fmt&quot;func main() &#123; res := addUpper() // 调用addUpper函数，得到一个闭包 fmt.Println(res()) // 输出：2 fmt.Println(res()) // 输出：3 fmt.Println(res()) // 输出：4 fmt.Println(res()) // 输出：5&#125;func addUpper() func() int &#123; x := 1 // 这是addUpper函数中的变量 return func() int &#123; // 返回一个匿名函数，这个函数是一个闭包 x++ // 闭包中修改了addUpper中的x return x &#125;&#125; addUpper函数返回了一个闭包，这个闭包“记住了”变量x。每次调用res()时，闭包都会增加x的值，并返回新的x值。因为闭包一直在使用x，所以x会一直存在，直到程序结束。 闭包的应用场景 封装状态：就像你的秘密配方不让别人看到，闭包可以封装状态，不让外部直接访问。 生成唯一资源：每次按照配方做蛋糕，都能保证蛋糕是独一无二的，闭包可以生成唯一的资源。 延迟初始化：就像你可以根据需要再决定是否做蛋糕，闭包可以实现延迟初始化。 闭包的注意事项 内存泄漏：如果你的秘密配方一直记得那些调料，即使你不再做蛋糕，那些调料也不会被清理掉，可能会导致资源浪费。 变量捕获：闭包会记住变量的最新状态，如果这些变量在外部被修改，闭包内部看到的也会是最新的状态。 函数异常处理在Go语言中，处理函数出错的情况有点像我们平时处理生活中的意外。想象你在一个餐厅工作，你的任务是确保顾客的订单正确无误。如果一切都顺利，你会把食物直接送到顾客那里。但有时候，厨房可能会出点问题，比如订单做错了或者食物烧焦了。这时候，你不能直接把问题食物给顾客，你需要先处理这个问题，可能是退回去重做，或者给顾客换个菜。 异常处理方式和其他语言（如 Java 或 Python）不同。Go 不支持传统的 try-catch 异常机制，而是依赖错误处理模式，通过返回值和 defer, panic, recover 机制来管理和捕获异常。 在Go语言中，我们有两种主要的方式来处理这种“厨房错误”： 错误返回值：这是最常见的方式，就像你检查食物是否做好了，如果没有，你会告诉顾客需要等一下。在Go中，函数会返回一个额外的值，通常是最后一个返回值，用来告诉你有没有错误发生。 Go语言中的错误处理主要依赖于error接口。error是一个接口，定义了Error()方法，返回错误信息。 函数可以通过返回error类型的值来指示是否发生错误。调用者需要检查这个错误值是否为nil，以确定函数是否成功执行。 1234567891011121314151617181920212223package mainimport ( &quot;errors&quot; &quot;fmt&quot;)// 定义一个简单的除法函数，返回除法结果和可能的错误func divide(a, b float64) (float64, error) &#123; if b == 0 &#123; return 0, errors.New(&quot;不能除以零&quot;) // 返回错误 &#125; return a / b, nil // 正常返回结果&#125;func main() &#123; result, err := divide(4, 0) // 测试除以零的情况 if err != nil &#123; fmt.Println(&quot;出错了:&quot;, err) return &#125; fmt.Println(&quot;结果是:&quot;, result)&#125; 1出错了: 不能除以零 defer：当你在函数中使用 defer 时，它会在函数返回之前执行。这常用于清理资源，比如关闭文件、网络连接等。即使函数中途遇到错误，defer 指定的操作仍会在函数结束前执行。后进先出（LIFO）的顺序执行。 123456789101112131415package mainimport &quot;fmt&quot;func cleanup() &#123; fmt.Println(&quot;Cleaning up resources&quot;)&#125;func main() &#123; defer cleanup() // 这行代码将cleanup函数调用延迟到main函数返回前执行 fmt.Println(&quot;Performing some work...&quot;) // 假设这里发生了一些工作&#125;//不管main函数中的工作是否正常完成，或者是否发生错误，cleanup函数都会被调用，以确保资源被清理。 12Performing some work...Cleaning up resources panic和recover：这种方式有点像处理厨房火灾这种紧急情况。panic就是当错误严重到无法处理时，你按下紧急按钮，让整个餐厅知道出事了。recover就像是紧急响应，可以在错误发生后采取措施，比如清理现场，防止餐厅完全停止营业。 panic是Go语言中用于触发异常的内置函数。当调用panic时，程序会立即停止当前函数的执行，并向上一层函数传递错误信息，这个过程会一直持续到程序终止或者被recover捕获。 panic可以带一个参数，通常是error类型的值，表示错误信息。 panic通常用于不可恢复的错误情况，比如程序逻辑中出现了严重的错误。 1234567891011121314151617package mainimport ( &quot;fmt&quot;)func causePanic() &#123; defer fmt.Println(&quot;defer 在 panic 后被执行&quot;) fmt.Println(&quot;函数开始&quot;) panic(&quot;遇到严重错误！&quot;) // 引发 panic。中断了正常执行，触发了所有 defer 执行，并打印错误信息。 fmt.Println(&quot;这行代码不会被执行&quot;)&#125;func main() &#123; causePanic()&#125; 123函数开始defer 在 panic 后被执行panic: 遇到严重错误！ recover是Go语言中用于捕获和处理panic的内置函数。只有在defer函数中调用recover才能成功捕获panic。 如果recover成功捕获panic，它会返回panic的值，否则返回nil。 使用recover可以恢复程序的执行，避免程序异常终止。 12345678910111213141516171819202122package mainimport ( &quot;fmt&quot;)func safeFunction() &#123; defer func() &#123;//recover 只能在 defer 函数中使用，用于捕获 panic。如果 panic 被捕获，程序不会崩溃，可以继续运行。 if r := recover(); r != nil &#123; fmt.Println(&quot;捕获到 panic:&quot;, r) &#125; &#125;() fmt.Println(&quot;safeFunction 开始&quot;) panic(&quot;引发 panic&quot;) // 引发 panic fmt.Println(&quot;safeFunction 结束&quot;)&#125;func main() &#123; safeFunction() fmt.Println(&quot;main 函数继续执行&quot;)&#125; 123safeFunction 开始捕获到 panic: 引发 panicmain 函数继续执行"},{"title":"Go基础语法","path":"/wiki/Go/基础语法/index.html","content":"Go语言是门面向对象的编程语言面向对象:化繁为简, 能不自己干自己就不干,关注的是我应该让谁来做? 变量 变量名必须以字母开头，可以包含字母、数字和下划线。 变量名不能以数字开头。 1234var 变量名 变量类型var name stringvar age int 12345var 变量名 类型 = 表达式var a int = 10var name string = &quot;yy&quot;//多个变量声明var x, y, z int = 1, 2, 3 123456789//自动类型推断： Go 允许根据初始值推断变量类型var a = 42 // 编译器推断 a 的类型为 intvar b = 3.14 // 编译器推断 b 的类型为 float64var c = &quot;hello&quot; // 编译器推断 c 的类型为 string//类型推断的前提是必须有初始化值。如果没有初始化值，编译器将无法推断类型。//例如，以下代码会报错： var a // 错误：编译器无法推断类型 推断类型与字面值一致。 12345c := 3.14 //使用 := 来给变量赋值,仅限于函数内使用d := 42 // 编译器推断 d 的类型为 inte := 3.14 // 编译器推断 e 的类型为 float64f := true // 编译器推断 f 的类型为 bool 1234567//批量声明var ( a string b int c bool d float32 ) 123456789101112131415161718//匿名变量package mainimport &quot;fmt&quot;func main() &#123; // 使用匿名变量存储函数参数 var _ = &quot;Hello, World!&quot; fmt.Println(_) // 打印匿名变量的值 // 使用匿名变量存储计算结果 var _, _ = 1, 2 fmt.Println(_, _) // 打印两个匿名变量的值&#125;//由于匿名变量没有名字，它们不会占用命名空间，因此它们之间不存在重复声明的问题//在 Go 中，匿名变量主要用于函数内部，以避免污染全局命名空间。 变量的零值 整型： int 类型的零值是 0。 uint 类型的零值是 0。 浮点型： float32 类型的零值是 0.0。 float64 类型的零值是 0.0。 布尔型： bool 类型的零值是 false。 字符串： string 类型的零值是空字符串 &quot;&quot;。 指针： 指针类型的零值是 nil。 切片： 切片类型的零值是空切片 []。 映射： 映射类型的零值是空映射 map&#123;&#125;。 通道： 通道类型的零值是 nil。 结构体： 结构体类型的零值是零值是结构体的零初始化，例如 struct&#123;&#125;。 接口： 接口类型的零值是 nil。 常量常量用于存储固定不变的值，其值在程序运行期间不能改变。使用 const 关键字声明常量。 声明了pi和e这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了 12const pi = 3.1415const e = 2.7182 枚举常量12345const ( A = iota // 0 B = iota // 1 C = iota // 2) 123456const ( n1 = iota //0 n2 //1 _ n4 //3 ) 1234567const ( n1 = iota //0 n2 = 100 //100 n3 = iota //2 n4 //3 )const n5 = iota //0 123456789101112131415161718package mainimport &quot;fmt&quot;func main() &#123; const ( a = iota // 这是第一次使用 iota，所以 a = 0 b // 这是第二次使用 iota，所以 b = 1 c // 这是第三次使用 iota，所以 c = 2 d = &quot;ha&quot; // 这里没有使用 iota，所以 iota 的计数器不会增加 e // 这是第四次使用 iota，所以 e = 0（因为上一次赋值重置了 iota） f = 100 // 这里没有使用 iota，所以 iota 的计数器不会增加 g // 这是第五次使用 iota，所以 g = 1（继续上一次的计数） h = iota // 这里显式地使用 iota，所以 h = 7（因为这是新的一轮，从0开始，然后增加7次） i // 这是第六次使用 iota，所以 i = 8 ) fmt.Println(a, b, c, d, e, f, g, h, i)&#125; 常量和变量在内存区域的存储Go 内存区域划分Go 语言中，内存通常分为三大区域： 全局静态区：存储全局变量和常量。这些变量和常量在程序启动时分配内存，并在程序结束时释放。 就像是家里的储藏室，存放不常变动的东西。 堆：存储动态分配的内存，通常用于需要在多个函数间共享的对象。堆上的数据需要手动管理或由 Go 的垃圾回收机制负责清理。 栈：用于函数调用时 栈与堆的差异 变量的内存存储 全局变量：全局变量声明在函数外，属于静态存储区，存储在全局静态区中。这些变量在程序启动时被分配，程序结束时被释放。全局变量的生命周期与程序的生命周期相同，程序一启动就会分配存储空间，直到程序结束。 局部变量：局部变量是在函数内部声明的，它们通常存储在栈上（如果不逃逸）。当函数调用时，栈帧会为局部变量分配内存；当函数返回时，这些栈内存会自动释放。如果局部变量逃逸到堆中，那么数据会存储在堆上。作用域：从定义哪一行开始直到与其所在的代码块结束 指针变量：指针变量存储在栈上或堆上，但它们指向的数据可以位于堆中。如果变量逃逸到堆中，那么数据会存储在堆上。 常量的内存存储 编译时常量：常量使用 const 关键字声明，它们通常在编译时确定，并且不会在运行时分配实际的存储空间。常量在内存中的表现方式与字面量类似，在很多情况下，编译器会直接将常量的值内联到使用它的地方。由于常量的值在编译时确定，因此它们不会像变量一样占用运行时内存。 只读常量：对于某些复杂常量（例如字符串），它们会存储在只读的内存区，通常位于全局静态区中。尽管这些常量不会在运行时更改，它们可能仍然占用一些内存资源。 内存逃逸分析在Go语言中，逃逸分析（escape analysis）是一种编译期优化技术，用于确定局部变量的存储位置。如果变量只在当前函数内部使用，并且没有被传递到其他函数或goroutine，那么这个变量通常存储在栈（stack）上。如果变量的生命周期超出了当前函数，比如被返回或传递给了其他goroutine，那么这个变量就会“逃逸”到堆（heap）上。 让我们用大白话来解释一下这个过程： 逃逸分析是什么？逃逸分析就像是侦探工作，编译器像侦探一样，追踪每个局部变量的去向。如果变量只在当前函数内部使用，那么它就老老实实地呆在栈上。但如果变量被带出了当前函数，比如被函数返回，或者被发送到另一个goroutine，那么它就需要一个更长久的家——堆。 为什么变量会逃逸到堆上？ 变量被返回： 如果一个变量的地址被返回，那么它可能被其他函数长时间持有，所以它需要存储在堆上，以免在函数返回后被销毁。 变量被传递给goroutine： 如果一个变量被传递给一个新的goroutine，那么它的生命周期就不再局限于当前函数，它需要在堆上分配内存，以确保在goroutine执行期间变量仍然有效。 什么时候会发生： 如果局部变量的生命周期超出了它所在的函数，比如被函数返回或者被传递给了其他的goroutine，那么它就需要一个更长久的存储位置，这时候它就会“逃逸”到堆上。 堆的作用： 堆就像是家里的储藏室，用来存放那些需要长时间保存的东西。在Go语言中，当局部变量逃逸到堆上时，就意味着它们被分配在堆上，可以被程序的其他部分长期访问。 1234func escapeExample() *int &#123; var x int = 42 // x 在栈上分配 return &amp;x // x 的地址被返回，x 逃逸到堆上&#125; Go数据类型 1234567891011121314151617181920212223242526272829303132333435363738package mainimport &quot;fmt&quot;func main() &#123; var intV int // 整型变量 var floatV float32 // 实型变量 var boolV bool // 布尔型变量 var stringV string // 字符串变量 var pointerV *int // 指针变量 var funcV func(int, int)int // function变量 var interfaceV interface&#123;&#125; // 接口变量 var sliceV []int // 切片变量 var channelV chan int // channel变量 var mapV map[string]string // map变量 var errorV error // error变量 fmt.Println(&quot;int = &quot;, intV) // 0 fmt.Println(&quot;float = &quot;, floatV) // 0 fmt.Println(&quot;bool = &quot;, boolV) // false fmt.Println(&quot;string = &quot;, stringV) // &quot;&quot; fmt.Println(&quot;pointer = &quot;, pointerV) // nil fmt.Println(&quot;func = &quot;, funcV) // nil fmt.Println(&quot;interface = &quot;, interfaceV) // nil fmt.Println(&quot;slice = &quot;, sliceV) // [] fmt.Println(&quot;slice = &quot;, sliceV == nil) // true fmt.Println(&quot;channel = &quot;, channelV) // nil fmt.Println(&quot;map = &quot;, mapV) // map[] fmt.Println(&quot;map = &quot;, mapV == nil) // true fmt.Println(&quot;error = &quot;, errorV) // nil var arraryV [3]int // 数组变量 type Person struct&#123; name string age int &#125; var structV Person // 结构体变量 fmt.Println(&quot;arrary = &quot;, arraryV) // [0, 0, 0] fmt.Println(&quot;struct = &quot;, structV) // &#123;&quot;&quot; 0&#125;&#125; 复合数据类型数组（Array）数组是具有固定长度的同类型元素集合。一旦定义，数组的长度就固定，不能改变。 123var arr [5]int = [5]int&#123;1, 2, 3, 4, 5&#125; // 定义一个长度为5的整型数组balance := [5]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;fmt.Println(len(arr)) // 输出数组长度 如果数组长度不确定，可以使用 … 代替数组的长度，编译器会根据元素个数自行推断数组的长度： 12var balance = [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125;balance := [...]float32&#123;1000.0, 2.0, 3.4, 7.0, 50.0&#125; 遍历数组 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; arr := [...]int&#123;1, 3, 5&#125; // 传统for循环遍历 for i:=0; i&lt;len(arr); i++&#123; fmt.Println(i, arr[i]) &#125; // for...range循环遍历 for i, v := range arr&#123; fmt.Println(i, v) &#125;&#125; 二维数组 12345678910package mainimport &quot;fmt&quot;func main() &#123; // 创建一个两行三列数组 arr := [2][3]int&#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, //注意: 数组换行需要以逗号结尾 &#125; fmt.Println(arr)// [[1 2 3] [4 5 6]] &#125; 12345678910package main import &quot;fmt&quot; func main() &#123; // 创建一个两行三列数组 arr := [...][3]int&#123; &#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#125; fmt.Println(arr)// [[1 2 3] [4 5 6]] &#125; 切片（Slice） 切片是基于数组的动态数组，长度可以变化，切片不需要指定长度，可以根据需求动态增减长度。 切片是引用类型，它是对底层数组的引用，因此修改切片会影响底层数组的内容。 切片由三个部分组成：指向底层数组的指针、切片的长度和切片的容量。 1234var s []int // 定义一个整数切片s := []int&#123;1, 2, 3, 4, 5&#125; // 定义并初始化切片s[0] = 10 // 修改第一个元素fmt.Println(s[0]) // 访问第一个元素 12var slice []int = []int&#123;1, 2, 3&#125;slice = append(slice, 4) // 动态扩展切片 123s1 := []int&#123;1, 2, 3&#125;s2 := make([]int, len(s1))copy(s2, s1) // 复制 s1 的内容到 s2 make函数创建 make(类型, 长度, 容量) 内部会先创建一个数组, 然后让切片指向数组 如果没有指定容量,那么容量和长度一样 12345678910111213package mainimport &quot;fmt&quot;func main() &#123; var sce = make([]int, 3, 5) fmt.Println(sce) // [0 0 0] fmt.Println(len(sce)) // 3 fmt.Println(cap(sce)) // 5 /* 内部实现原理 var arr = [5]int&#123;0, 0, 0&#125; var sce = arr[0:3] */&#125; 123456var slice4 []int = []int&#123;1,2,3,4,5&#125;var slice5 = make([]int,10)copy(slice5,slice4) //将切片slice4拷贝为slice5fmt.Println(slice4) //1,2,3,4,5fmt.Println(slice5) //1,2,3,4,5,0,0,0,0,0//默认情况下，使用make后，多余的空间默认为0 123456type slice struct&#123; array unsafe.Pointer // 切片的底层实现是指向数组的指针 len int // 切片长度(保存了多少个元素) cap int // 切片容量(可以保存多少个元素)&#125;//cap 总是大于等于 len 1234567891011121314151617package mainimport(&quot;fmt&quot;)func main()&#123; var intArr [5]int = [...]int&#123;11,22,33,44,55&#125; //数组 slice := intArr[1:3] fmt.Println(&quot;intarr=&quot;,intArr) //intArr= [11 22 33 4 55] fmt.Println(&quot;intarr的容量是 &quot;,len(inArr)) //intArr的容量是 5 fmt.Println(&quot;slice 的元素是 &quot;,slice) //slice 的元素是 [22 33] //数组的第二个元素（下标为 1）到第三个元素（下标为 3）的切片。 //切片不包含第四个元素（下标为 3） fmt.Println(&quot;slice 的容量是&quot;,cap(slice)) //slice 的容量是 2 //切片的容量是可变的，这意味着你可以在切片的生命周期内增加切片的长度。 //切片的长度是不可变的，但是你可以在切片上添加或删除元素，从而改变切片的长度。 fmt.Println(&quot;slice 的元素个数为&quot;,len(slice)) //slice 元素个数为 2 &#125; 1234//切片可以被进一步切片，产生新的切片s := []int&#123;1, 2, 3, 4, 5&#125;s1 := s[1:4] // s1 为 [2, 3, 4]s2 := s[2:] // s2 为 [3, 4, 5] 12345678//切片可以作为函数参数，并可以直接在函数内部修改。由于切片是引用类型，函数内的修改会影响原切片func modifySlice(s []int) &#123; s[0] = 100 // 修改切片的第一个元素&#125;s := []int&#123;1, 2, 3&#125;modifySlice(s)fmt.Println(s) // 输出 [100, 2, 3] 字典（Map）字典是一种键值对数据结构，用于高效地存储和检索元素。 12//map格式:var dic map[key数据类型]value数据类型var m map[string]int = map[string]int&#123;&quot;foo&quot;: 1, &quot;bar&quot;: 2&#125; map的增删改查 增加 当 map 中没有指定的键时，就会自动增加键值对。 12345678910package mainimport &quot;fmt&quot;func main() &#123; var dict = make(map[string]string) fmt.Println(&quot;增加前:&quot;, dict) // map[] dict[&quot;name&quot;] = &quot;ln&quot; fmt.Println(&quot;增加后:&quot;, dict) // map[name:ln]&#125; 修改 当 map 中有指定的键时，就会自动修改键对应的值。 12345678910package mainimport &quot;fmt&quot;func main() &#123; var dict = map[string]string&#123;&quot;name&quot;: &quot;ln&quot;, &quot;age&quot;: &quot;3&quot;, &quot;gender&quot;: &quot;male&quot;&#125; fmt.Println(&quot;修改前:&quot;, dict) // map[name:ln age:3 gender:male] dict[&quot;name&quot;] = &quot;zs&quot; fmt.Println(&quot;修改后:&quot;, dict) // map[name:zs age:3 gender:male]&#125; 删除 可以通过 Go 语言内置的 delete 函数删除指定键的元素。 123456789101112package mainimport &quot;fmt&quot;func main() &#123; var dict = map[string]string&#123;&quot;name&quot;: &quot;ln&quot;, &quot;age&quot;: &quot;3&quot;, &quot;gender&quot;: &quot;male&quot;&#125; fmt.Println(&quot;删除前:&quot;, dict) // map[name:ln age:3 gender:male] // 第一个参数: 被操作的字典 // 第二个参数: 需要删除元素对应的键 delete(dict, &quot;name&quot;) fmt.Println(&quot;删除后:&quot;, dict) // map[age:3 gender:male]&#125; 查询 通过 ok-idiom 模式判断指定键值是否存储。 12345678910111213141516package mainimport &quot;fmt&quot;func main() &#123; var dict = map[string]string&#123;&quot;name&quot;: &quot;ln&quot;, &quot;age&quot;: &quot;3&quot;, &quot;gender&quot;: &quot;male&quot;&#125; // value, ok := dict[&quot;age&quot;] //if(ok)&#123; // fmt.Println(&quot;有age这个key,值为&quot;, value) //&#125;else&#123; // fmt.Println(&quot;没有age这个key,值为&quot;, value) // &#125; if value, ok := dict[&quot;age&quot;]; ok&#123; fmt.Println(&quot;有age这个key,值为&quot;, value) fmt.Println(&quot;没有age这个key,值为&quot;, !ok)&#125; 遍历 遍历 map 时，map 中存储的数据是无序的，所以多次输出的顺序可能不同。 1234var dict = map[string]string&#123;&quot;name&quot;: &quot;ln&quot;, &quot;age&quot;: &quot;3&quot;, &quot;gender&quot;: &quot;male&quot;&#125;for key, value := range dict &#123; fmt.Println(key, value)&#125; 结构体（Struct）结构体是一种复合数据类型，用于将不同类型的数据组合在一起。 12345type Person struct &#123; Name string // 结构体类型中的字段 Age int&#125; 123456p := Person&#123; FirstName: &quot;John&quot;, LastName: &quot;Doe&quot;, Age: 30,&#125;fmt.Println(p.FirstName) // 输出: John 指针（Pointer）指针存储变量的内存地址。Go 不支持指针运算，但可以通过指针来改变原变量的值。 123var x int = 10var p *int = &amp;x // p 存储 x 的内存地址*p = 20 // 修改 x 的值为 20 特殊数据类型接口（Interface）接口定义了一组方法，而不实现这些方法。实现接口的具体类型必须实现接口中定义的所有方法。 123type Speaker interface &#123; Speak()&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243package mainimport &quot;fmt&quot;// 1.定义一个接口type usber interface &#123; start() stop()&#125;type Computer struct &#123; name string model string&#125;// 2.实现接口中的所有方法func (cm Computer)start() &#123; fmt.Println(&quot;启动电脑&quot;)&#125;func (cm Computer)stop() &#123; fmt.Println(&quot;关闭电脑&quot;)&#125;type Phone struct &#123; name string model string&#125;// 2.实现接口中的所有方法func (p Phone)start() &#123; fmt.Println(&quot;启动手机&quot;)&#125;func (p Phone)stop() &#123; fmt.Println(&quot;关闭手机&quot;)&#125;// 3.使用接口定义的方法func working(u usber) &#123; u.start() u.stop()&#125;func main() &#123; cm := Computer&#123;&quot;戴尔&quot;, &quot;F1234&quot;&#125; working(cm) // 启动电脑 关闭电脑 p := Phone&#123;&quot;华为&quot;, &quot;M10&quot;&#125; working(p) // 启动手机 关闭手机&#125; 在Go语言中，接口是一种类型，它定义了一组方法。如果一个类型实现了接口中声明的所有方法，我们就说这个类型实现了这个接口。多态就是通过接口来实现的，它允许你使用接口类型的变量来引用任何实现了该接口的具体类型。 接口定义行为：接口是方法的集合，定义了行为的抽象。 类型自动实现接口：Go 没有显式的 implements 关键字，只要类型实现了接口中的方法，它就自动被视为该接口类型。 多态性：通过接口，Go 实现了多态性。我们可以通过接口类型变量来调用不同实现的类型。 接口解耦：接口将高层逻辑和具体实现分离，易于扩展和维护。 123456789101112131415161718192021222324252627282930313233343536373839404142434445package mainimport ( &quot;fmt&quot;)//第一步：定义接口（行为描述）// Animal接口，包含一个Speak方法//Speak 是接口的方法签名，表示所有 Animal 都可以发出声音type Animal interface &#123; Speak() string // Speak方法返回一个字符串&#125;//第二步：定义实现接口的具体类型// Dog 结构体，代表狗type Dog struct&#123;&#125;// Cat 结构体，代表猫type Cat struct&#123;&#125;//只要它们定义了 Speak 方法，Go 就会自动识别它们为 Animal 类型// Dog 实现了 Animal 接口的 Speak 方法func (d Dog) Speak() string &#123; return &quot;Woof!&quot; // 狗叫声&#125;// Cat 实现了 Animal 接口的 Speak 方法func (c Cat) Speak() string &#123; return &quot;Meow!&quot; // 猫叫声&#125;//第三步：使用接口实现多态// MakeSound 接收一个 Animal 类型的参数，并调用其 Speak 方法func MakeSound(a Animal) &#123; fmt.Println(a.Speak())&#125;func main() &#123; dog := Dog&#123;&#125; // 创建Dog实例 cat := Cat&#123;&#125; // 创建Cat实例 // 调用MakeSound时，可以传入任何实现了Animal接口的类型 MakeSound(dog) // 输出：Woof! MakeSound(cat) // 输出：Meow!&#125; 12Woof!Meow! 进阶示例：增加更多的实现类型 12345678910111213141516171819202122232425// 定义 Cow 结构体，代表牛type Cow struct&#123;&#125;// 定义 Duck 结构体，代表鸭type Duck struct&#123;&#125;// 实现 Cow 的 Speak 方法func (c Cow) Speak() string &#123; return &quot;Moo!&quot; // 牛的叫声&#125;// 实现 Duck 的 Speak 方法func (d Duck) Speak() string &#123; return &quot;Quack!&quot; // 鸭的叫声&#125;func main() &#123; // 创建一个包含不同 Animal 类型的切片 animals := []Animal&#123;Dog&#123;&#125;, Cat&#123;&#125;, Cow&#123;&#125;, Duck&#123;&#125;&#125; // 遍历 animals 切片，调用每个 Animal 的 Speak 方法 for _, animal := range animals &#123; MakeSound(animal) &#125;&#125; 1234Woof!Meow!Moo!Quack! 面向对象设计思想与接口的关系 在面向对象设计中，接口扮演了模块间的“通信契约”，它帮助我们分离具体实现和高层逻辑： 抽象和封装：接口提供了一种抽象，定义了一组方法，而不关心方法的具体实现。每个实现接口的类型可以有不同的内部逻辑，但对外表现一致。 多态性：接口允许我们在不同类型之间实现多态，即用同一个接口类型的变量来操作不同的具体类型。在本例中，Animal 接口实现了多态性，使得 Dog、Cat、Cow、Duck 都可以作为 Animal 来使用。 解耦和扩展性：接口使代码更加解耦。调用者只需要知道接口，而不需要关心具体实现，符合“依赖于抽象而不依赖于具体”的设计原则。这种模式特别适合需要不断扩展的新类型需求。 类型断言 用于检查接口变量（interface）中实际存储的值的类型，并在检查的同时进行类型转换。 检查接口变量中存储的具体类型：当你不确定接口变量中存储的是哪个具体类型时，可以使用类型断言来检查。 从接口变量中提取具体类型的值：接口变量只能调用接口中定义的方法，如果你需要调用具体类型的方法，可以使用类型断言来提取具体的值。 12双值形式：t, ok := i.(Type)单值形式：t := i.(Type)，如果类型不匹配，会直接引发 panic 12345i 是接口变量。Type 是要断言的具体类型。t 是断言成功后的具体类型的变量。ok 是一个布尔值，表示断言是否成功。如果 i 的实际类型与 Type 相同，那么 t 会是 Type 类型的变量，ok 为 true。如果类型不匹配，则 ok 为 false，t 的值为零值。 1234567891011121314151617func main() &#123; var a Animal = Dog&#123;&#125; // 双值形式，安全判断类型 dog, ok := a.(Dog) if ok &#123; fmt.Println(&quot;a 是 Dog 类型:&quot;, dog.Speak()) &#125; else &#123; fmt.Println(&quot;a 不是 Dog 类型&quot;) &#125; // 单值形式，不建议使用 // 如果 a 不是 Cat 类型，会触发 panic cat := a.(Cat) // 这里会触发 panic，因为 a 不是 Cat 类型 fmt.Println(&quot;a 是 Cat 类型:&quot;, cat.Speak())&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package mainimport ( &quot;fmt&quot;)// Animal接口，所有动物都可以Speaktype Animal interface &#123; Speak() string&#125;// Dog 结构体，实现了 Animal 接口type Dog struct&#123;&#125;func (d Dog) Speak() string &#123; return &quot;Woof!&quot;&#125;// Cat 结构体，实现了 Animal 接口type Cat struct&#123;&#125;func (c Cat) Speak() string &#123; return &quot;Meow!&quot;&#125;func main() &#123; var a Animal a = Dog&#123;&#125; // 将 Dog 实例赋值给接口变量 a // 类型断言：检查 a 是否是 Dog 类型 dog, ok := a.(Dog) if ok &#123; fmt.Println(&quot;a 是 Dog 类型，叫声是:&quot;, dog.Speak()) &#125; else &#123; fmt.Println(&quot;a 不是 Dog 类型&quot;) &#125; // 再次断言 a 是否是 Cat 类型 cat, ok := a.(Cat) if ok &#123; fmt.Println(&quot;a 是 Cat 类型，叫声是:&quot;, cat.Speak()) &#125; else &#123; fmt.Println(&quot;a 不是 Cat 类型&quot;) &#125;&#125; 12a 是 Dog 类型，叫声是: Woof!a 不是 Cat 类型 type switch：简化多种类型断言 1234567891011switch v := x.(type) &#123;case T1: // 如果 x 存储的值是类型 T1，执行这里的代码case T2: // 如果 x 存储的值是类型 T2，执行这里的代码case T3: // 如果 x 存储的值是类型 T3，执行这里的代码// ...default: // 如果 x 存储的值不匹配以上任何类型，执行这里的代码&#125; 123x 是一个接口类型的变量。v := x.(type) 是 type switch 的声明部分，v 是一个新的变量，它将存储 x 中实际存储的值。T1、T2、T3 等是你要检查的类型。 12345678910111213141516func DescribeAnimal(a Animal) &#123; switch v := a.(type) &#123; case Dog: fmt.Println(&quot;这是一只狗，它的叫声是:&quot;, v.Speak()) case Cat: fmt.Println(&quot;这是一只猫，它的叫声是:&quot;, v.Speak()) default: fmt.Println(&quot;未知类型的动物&quot;) &#125;&#125;func main() &#123; DescribeAnimal(Dog&#123;&#125;) // 输出：这是一只狗，它的叫声是: Woof! DescribeAnimal(Cat&#123;&#125;) // 输出：这是一只猫，它的叫声是: Meow!&#125; 函数（Function）函数在 Go 中也是一种数据类型，可以作为参数或返回值传递给其他函数。 123func add(a, b int) int &#123; return a + b&#125; 通道（Channel）通道是 Go 语言中的一种用于并发的类型，用于在 goroutine 之间传递数据。 你在一家餐厅里，餐厅里有厨房和餐桌。厨师们在厨房里做好菜，然后需要把菜送到顾客的餐桌上。但是，我们不能让厨师直接冲到顾客面前送菜，这样会乱套的。所以，餐厅里有一种叫做“传菜口”的东西，厨师把菜通过传菜口递出来，服务员从传菜口取走菜，然后送到顾客的桌子上。 在Go语言里，通道（Channel）就有点像这个“传菜口”。它是一个让不同的工作线程（我们叫它们“goroutine”）之间传递消息和数据的通道。这些goroutine就像是厨师和服务员，它们不能直接交换东西，而是通过通道来传递。 通道的几个特点： 类型安全：就像传菜口只能递菜一样，Go语言中的通道也只能传递一种类型的数据。 同步：通道保证了数据的发送和接收是同步的。就像厨师把菜放进传菜口，必须有服务员来取走，才能继续做菜。 缓冲：有些通道可以存一些数据，就像传菜口可以暂时放几盘菜一样。如果通道里已经存满了菜，厨师就得等服务员取走一些，才能放下一盘新菜。 关闭：就像餐厅打烊后，厨师不会再做菜，通道也可以关闭，表示不会再有新的数据发送进来了。 为什么需要通道： 在Go语言里，我们经常需要同时做几件事情（并发），就像餐厅里同时有几桌顾客点菜一样。通道就是确保这些同时进行的事情能够协调工作，不会乱套的一种方式。它不仅让数据传递变得有序，还能保证数据的安全，因为数据只能在通道里传递，不会被别的程序或者goroutine乱改。 通道有 发送（send）、接收(receive）和 关闭（close）三种操作。 发送和接收都使用&lt;-符号。 无缓冲的channel在发送和接收数据时是同步的: 发送操作：当一个goroutine向无缓冲的channel发送数据时，它必须等待另一个goroutine来接收这个数据，否则发送操作会一直阻塞。 接收操作：同样地，当一个goroutine从无缓冲的channel接收数据时，它也必须等待另一个goroutine发送数据，否则接收操作会一直阻塞。 同步：无缓冲的channel确保了发送和接收操作的同步性，即数据的发送和接收是严格交替进行的。 使用场景：无缓冲的channel常用于需要严格同步操作的场景，比如协调两个goroutine的工作流程。 1234567891011package mainimport ( &quot;fmt&quot;)func main() &#123; ch := make(chan int) // 无缓冲区的 channel go func() &#123; //启动了一个匿名的goroutine，在这个goroutine中，我们向channel ch 发送了数字 42 ch &lt;- 42 // 发送数据会阻塞，直到有接收者 &#125;() // 接收数据 value := &lt;-ch fmt.Println(&quot;接收到的值:&quot;, value) // 输出: 接收到的值: 42，解除阻塞&#125; 有缓冲的channel（类比电话留言箱，无需对方立即接听）允许在没有接收者的情况下发送一定数量的数据，这个数量就是channel的缓冲大小： 发送操作：如果缓冲区未满，发送数据到有缓冲的channel不会阻塞，数据会被放入缓冲区中。只有当缓冲区满了，发送者才会阻塞，直到缓冲区有空间。 接收操作：如果缓冲区不为空，从有缓冲的channel接收数据不会阻塞，因为可以直接从缓冲区中取出数据。只有当缓冲区空了，接收者才会阻塞，直到有数据发送到channel。 异步：有缓冲的channel允许一定程度的异步操作，因为数据可以先存储在缓冲区中，不必立即被接收。 使用场景：有缓冲的channel适用于生产者-消费者问题，其中生产者可以快速地将数据放入缓冲区，而消费者则可以异步地从缓冲区中取出数据 注意：在关闭 channel 后，不要再向其发送数据，这样会引发 panic。 12345678910111213141516package mainimport &quot;fmt&quot;func main() &#123; tasks := make(chan int, 10) // 创建一个缓冲大小为10的channel for i := 0; i &lt; 10; i++ &#123; fmt.Println(&quot;task &quot;, i) tasks &lt;- i // 向channel发送数据。不阻塞，缓冲区有空间 &#125; close(tasks) // 发送完毕后关闭channel，不再有数据发送，可以结束接收循环了。 for task := range tasks &#123; fmt.Println(&quot;处理任务:&quot;, task) // 从channel接收并处理数据 &#125;&#125; 数据类型转换Go 是静态类型语言，必须显式地进行类型转换，不能像某些动态语言一样自动进行隐式类型转换。 12var a int = 10var b float64 = float64(a) // int 转换为 float64 运算符 Go语言中++、–运算符不支持前置 错误写法: ++i; –i; Go语言中++、–是语句,不是表达式,所以必须独占一行 错误写法: a &#x3D; i++; return i++; 123456789101112a := 6 // 110 in binaryb := 3 // 011 in binaryfmt.Println(a &amp; b) // 结果为2 （010 in binary）//只有当两个操作数的对应位都为1时，结果位才为1。因此，结果为 010（十进制下为2）fmt.Println(a | b) // 结果为7 （111 in binary）//只要两个操作数的对应位有一个为1，结果位就为1。因此，结果为 111（十进制下为7）fmt.Println(a ^ b) // 结果为5 （101 in binary）//只要两个操作数的对应位不同，结果位就为1。因此，结果为 101（十进制下为5）fmt.Println(a &lt;&lt; 1) // 结果为12 （1100 in binary）//a &lt;&lt; 1 将 a 的二进制表示 110 向左移动1位，相当于乘以2的1次方。因此，结果为 1100（十进制下为12fmt.Println(b &gt;&gt; 1) // 结果为1 （001 in binary）//b &gt;&gt; 1 将 b 的二进制表示 011 向右移动1位，相当于除以2的1次方。因此，结果为 001（十进制下为1） 123456789101112 package mainimport &quot;unsafe&quot;const ( a = &quot;abc&quot; b = len(a) c = unsafe.Sizeof(a)) func main()&#123; println(a, b, c) &#125;//以上实例运行结果为：abc 3 16 流程控制常见的分支控制语句包括 if、else、switch、select&#x20; for 循环：Go 中的循环结构主要通过 for 语句实现。Go 没有像其他语言中的 while 和 do-while 循环，而是用 for 语句可以完成所有的循环需求。 123456for i := 0; i &lt; 5; i++ &#123; if i == 3 &#123; continue // 跳过 i 等于 3 的那次循环 &#125; fmt.Println(i)&#125; for…range 循环：for...range 循环用于遍历数组、切片（slice）、map、字符串等集合类型的数据。 1234nums := []int&#123;1, 2, 3, 4, 5&#125;for index, value := range nums &#123; fmt.Printf(&quot;索引: %d, 值: %d &quot;, index, value)&#125; select 语句：是 Go 特有的，用于处理多个通道（channel）的通信操作。它类似于 switch，但每个 case 都必须是一个通道操作。 12345678910select &#123; case &lt;- channel1: // 读取 channel1 的数据，channel1准备好了 case data := &lt;- channel2: //用 data 去接收数据 case channel3 &lt;- data: // 往 channel3 中写入数据 default: // 没有任何channel准备好了&#125; 123456789101112131415161718192021222324252627282930313233package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() &#123; ch1 := make(chan string) ch2 := make(chan string) go func() &#123; time.Sleep(2 * time.Second) ch1 &lt;- &quot;from ch1&quot; //第一个goroutine在2秒后向ch1发送字符串&quot;from ch1&quot; &#125;() go func() &#123; time.Sleep(1 * time.Second) ch2 &lt;- &quot;from ch2&quot; //第二个goroutine在1秒后向ch2发送字符串&quot;from ch2&quot; &#125;() select &#123; case msg1 := &lt;-ch1: fmt.Println(msg1) //第一个goroutine在2秒后向ch1发送字符串&quot;from ch1&quot; case msg2 := &lt;-ch2: fmt.Println(msg2) //第二个goroutine在1秒后向ch2发送字符串&quot;from ch2&quot; case &lt;-time.After(3 * time.Second): //超时，time.After(3 * time.Second)表示如果3秒内没有其他事件发生，则触发超时 fmt.Println(&quot;timeout&quot;) &#125;&#125;//由于ch2的goroutine会在1秒后发送消息，这比ch1的goroutine和超时时间都要早//所以select会首先执行ch2的case，打印出&quot;from ch2&quot; 循环配合 defer 使用：在循环中，defer 语句会在当前函数返回之前按照后进先出的顺序执行。通常用于在循环中执行一些延迟操作比如文件关闭、资源释放等。 123for i := 0; i &lt; 3; i++ &#123; defer fmt.Println(&quot;延迟执行:&quot;, i)&#125; 12345678910111213141516171819package mainimport &quot;fmt&quot;func main() &#123; defer func1() defer func2() defer func3() &#125; func func1() &#123; fmt.Println(&quot;A&quot;) &#125; func func2() &#123; fmt.Println(&quot;B&quot;) &#125; func func3() &#123; fmt.Println(&quot;C&quot;) &#125; 123CBA 12345678910111213141516171819202122package mainimport &quot;fmt&quot;func deferFunc() int &#123; fmt.Println(&quot;defer func called&quot;) return 0&#125;func returnFunc() int &#123; fmt.Println(&quot;return func called&quot;) return 0&#125;func returnAndDefer() int &#123; defer deferFunc() // 这将延迟执行deferFunc，直到本函数返回 return returnFunc() // 调用returnFunc并返回其结果&#125;func main() &#123; returnAndDefer() // 调用returnAndDefer，但不接收其返回值&#125; 123return func calleddefer func called//return语句总是先于defer语句执行 嵌套循环：Go 允许在循环内嵌套其他循环，以实现更复杂的逻辑。 1234for i := 1; i &lt;= 3; i++ &#123; for j := 1; j &lt;= 3; j++ &#123; fmt.Printf(&quot;i: %d, j: %d &quot;, i, j) &#125; 在 Go 语言中，字符串是由两部分组成的： 字符串的长度：告诉我们字符串包含多少个字符。 指向字符串内容的指针：指向存储字符串实际字符数据的地方。 指针：它指向字符串数据的实际存储位置。通常，在 64 位系统中，这个指针占用 8 字节。 长度：这是一个整数，用来表示字符串的长度。在 64 位系统中，整数类型通常占用 8 字节。 因此，字符串的总大小计算如下： 指针（8 字节） 长度（8 字节） 8 字节 (指针)+8 字节 (长度)&#x3D;16 字节"}]